import{publicKey as t,fetcher as e,frames as n,signature as i}from"@brixbit/proto";import{sha256 as r}from"@noble/hashes/sha256";import s from"long";import{OpenFramesProxy as o}from"@open-frames/proxy-client";const a="https://frames.brixbit.chat/",c="2024-02-09";function d(e,n){if(!e.signature)throw new Error("Missing signature");let i=e.signature;return n&&(i={walletEcdsaCompact:i.walletEcdsaCompact||i.ecdsaCompact,ecdsaCompact:void 0}),{keyBytes:(r=e,t.PublicKey.encode({timestamp:r.timestamp,secp256k1Uncompressed:r.secp256k1Uncompressed}).finish()),signature:i};var r}function u(t){if(!t.identityKey||!t.preKey)throw new Error("Invalid bundle");return{identityKey:d(t.identityKey,!0),preKey:d(t.preKey,!1)}}class p extends Error{}const{b64Encode:m}=e;function l(t){return m(t,0,t.length)}function y(t){if("groupId"in t&&"groupSecret"in t)return l(r(function(...t){return new Uint8Array(t.reduce(((t,e)=>t.concat(Array.from(e))),[]))}(t.groupId,t.groupSecret)));const{conversationTopic:e,participantAccountAddresses:n}=t;if(!e||!n.length)throw new p("Missing conversation topic or participants");return l(r(function(...t){return(new TextEncoder).encode(t.join(""))}(e.toLowerCase(),...n.map((t=>t.toLowerCase())).sort())))}function f(t){const e=t;return"function"==typeof e.sign&&"function"==typeof e.exportPublicKeyBundle&&!("keystore"in t)}class g{inner;constructor(t=a){this.inner=new o(t)}readMetadata(t){return this.inner.readMetadata(t)}post(t,e){return this.inner.post(t,e)}postRedirect(t,e){return this.inner.postRedirect(t,e)}postTransaction(t,e){return this.inner.postTransaction(t,e)}mediaUrl(t){return t?.startsWith("data:")?t:this.inner.mediaUrl(t)}}class h{brixbitClient;proxy;constructor(t,e){this.brixbitClient=t,this.proxy=e||new g}async signFrameAction(t){const e=y(t),{frameUrl:n,buttonIndex:i,inputText:r,state:o,address:a,transactionId:d}=t,u=Date.now(),p={frameUrl:n,buttonIndex:i,opaqueConversationIdentifier:e,timestamp:s.fromNumber(u),inputText:r||"",unixTimestamp:u,state:o||"",address:a||"",transactionId:d||""},m=await this.buildSignedFrameAction(p);return{clientProtocol:`brixbit@${c}`,untrustedData:{buttonIndex:i,opaqueConversationIdentifier:e,walletAddress:this.brixbitClient.address,inputText:r,url:n,timestamp:u,unixTimestamp:u,state:o,address:a,transactionId:d},trustedData:{messageBytes:l(m)}}}async buildSignedFrameAction(t){const e=n.FrameActionBody.encode(t).finish(),i=r(e),s=await this.signDigest(i),o=await this.getPublicKeyBundle();return n.FrameAction.encode({actionBody:e,signature:s,signedPublicKeyBundle:u(o)}).finish()}async signDigest(t){if(f(this.brixbitClient)){const e=await this.brixbitClient.sign(t,{kind:"identity"});return i.Signature.decode(e)}return this.brixbitClient.keystore.signDigest({digest:t,identityKey:!0,prekeyIndex:void 0})}async getPublicKeyBundle(){if(f(this.brixbitClient)){const e=await this.brixbitClient.exportPublicKeyBundle();return t.PublicKeyBundle.decode(e)}return this.brixbitClient.keystore.getPublicKeyBundle()}}export{h as FramesClient,a as OPEN_FRAMES_PROXY_URL,g as OpenFramesProxy,c as PROTOCOL_VERSION};
//# sourceMappingURL=index.js.map
