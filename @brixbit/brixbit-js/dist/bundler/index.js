import{getAddress as e,bytesToHex as t,keccak256 as s,hexToSignature as r,hexToBytes as n,hashMessage as i,verifyMessage as o}from"viem";import a from"long";import{fetcher as c,ciphertext as d,privateKey as h,signature as y,publicKey as u,keystore as p,message as l,content as w,messageApi as f,contact as m,authn as g,invitation as v,privatePreferences as b,composite as E}from"@brixbit/proto";import*as K from"@noble/secp256k1";import{Mutex as k}from"async-mutex";import T from"elliptic";import{user_preferences_encrypt as A,user_preferences_decrypt as S,generate_private_preferences_topic as C}from"@brixbit/user-preferences-bindings-wasm/bundler";const P=e=>`/brixbit/0/${e}/proto`,B=(t,s)=>{const r=[e(t),e(s)];return r.sort(),P(`dm-${r.join("-")}`)},I=e=>P(`m-${e}`),R=t=>P(`contact-${e(t)}`),N=t=>P(`intro-${e(t)}`),D=t=>P(`invite-${e(t)}`),M=e=>P(`privatestore-${e}`),_=e=>P(`userpreferences-${e}`),x=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const r=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(r)}return!1},V=e=>new Promise((t=>setTimeout(t,e))),U=e=>!!e;async function q(e,t,s,r,n=U,i=1){const o="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!n(i)||o>s)throw i;return await V(r),q(e,t,s,r,n,o+1)}}async function*O(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),r=[];for(const t of e)"fulfilled"===t.status?r.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield r}}function L(e){return a.fromNumber(e.valueOf()).multiply(1e6)}function F(e){return new Date(e.divide(1e6).toNumber())}const G=e=>e&&L(e).toString(),H=e=>{if(e)return F(a.fromString(e))},{b64Decode:$,b64Encode:j}=c;function X(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function J(e){const[t,s,...r]=e.split(".");return{major:Number(t),minor:Number(s),patch:r.join(".")}}function z(e,t){if(!e||!t)return!1;const s=J(e),r=J(t);return s.major!==r.major?s.major>r.major:s.minor!==r.minor?s.minor>r.minor:!(!s.patch||!r.patch)&&function(e,t){const[s,r]=e.split("-"),[n,i]=t.split("-");if(Number(s)!==Number(n))return Number(s)>Number(n);if(!r||!i)return!1;const[o,a]=r.split("."),[c,d]=i.split(".");if(o!==c)return!0;return Number(a)>Number(d)}(s.patch,r.patch)}function Y(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}class W{constructor(e,t,s,r,n){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,r),this.onConnectionLost=n}newMessageCallback(e,t){return async s=>{if(s.message)try{const r=await e(s);if(!r)return;if(t){const e=t(r);e&&this.resubscribeToTopics(e)}const n=this.resolvers.pop();n?n({value:r}):this.messages.unshift(r)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,r,n){const i=new W(e,t,s,r,n);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}class Q{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return d.Ciphertext.encode(this).finish()}static fromBytes(e){return new Q(d.Ciphertext.decode(e))}}const Z=window.crypto,ee=(new Uint8Array).buffer;async function te(e){return new Uint8Array(await Z.subtle.digest("SHA-256",e))}async function se(e,t,s){const r=Z.getRandomValues(new Uint8Array(32)),n=Z.getRandomValues(new Uint8Array(12)),i=await ie(t,r),o=await Z.subtle.encrypt(ne(n,s),i,e);return new Q({aes256GcmHkdfSha256:{payload:new Uint8Array(o),hkdfSalt:r,gcmNonce:n}})}async function re(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const r=await ie(t,e.aes256GcmHkdfSha256.hkdfSalt),n=await Z.subtle.decrypt(ne(e.aes256GcmHkdfSha256.gcmNonce,s),r,e.aes256GcmHkdfSha256.payload);return new Uint8Array(n)}function ne(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function ie(e,t){const s=await Z.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return Z.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:ee},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}const oe=K.utils.bytesToHex;function ae(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function ce(e){const t=r(e),s=n(t.r),i=n(t.s);let o=Number(t.v);0!==o&&1!==o||(o+=27);const a=1-o%2,c=new Uint8Array(64);return c.set(s),c.set(i,s.length),{bytes:c,recovery:a}}function de(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class he{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(de(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new be(e.publicKey)}static async generate(e){const t={bytes:K.utils.randomPrivateKey()},s=a.fromNumber((new Date).getTime()).mul(1e6),r=new ve({secp256k1Uncompressed:{bytes:K.getPublicKey(t.bytes)},createdNs:s}),n=await e.signKey(r);return new he({secp256k1:t,createdNs:s,publicKey:n})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await K.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new we({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await te(t),r=await this.sign(s);return new be({keyBytes:t,signature:r})}static async signerKey(e,t){return le(await te(e.bytesToSign()),t)}sharedSecret(e){return K.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return se(e,this.sharedSecret(t),s)}decrypt(e,t,s){return re(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return ae(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return h.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return ae(K.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new he(h.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new he({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:be.fromLegacyKey(e.publicKey,t)})}}class ye{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(de(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new Ee(e.publicKey)}static generate(){const e={bytes:K.utils.randomPrivateKey()},t=a.fromNumber((new Date).getTime());return new ye({secp256k1:e,timestamp:t,publicKey:new Ee({secp256k1Uncompressed:{bytes:K.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await K.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new we({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await te(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return K.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return se(e,this.sharedSecret(t),s)}decrypt(e,t,s){return re(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return ae(K.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return h.PrivateKey.encode(this).finish()}static fromBytes(e){return new ye(h.PrivateKey.decode(e))}}function ue(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function pe(e,t){return e.recovery===t.recovery&&ae(e.bytes,t.bytes)}function le(e,t){const s=K.recoverPublicKey(e,t.bytes,t.recovery);return s?new ve({secp256k1Uncompressed:{bytes:s},createdNs:a.fromNumber(0)}):void 0}class we{constructor(e){if(e.ecdsaCompact)ue(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");ue(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?he.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?me.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=K.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=K.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new Ee({secp256k1Uncompressed:{bytes:t},timestamp:a.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?pe(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&pe(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return y.Signature.encode(this).finish()}static fromBytes(e){return new we(y.Signature.decode(e))}}var fe;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(fe||(fe={}));class me{constructor(e){this.wallet=e}static identitySigRequestText(e){return`BRIXBIT : Create Identity\n${oe(e)}\n\nFor more info: https://brixbit.org/signatures/`}static signerKey(e,t){return le(n(i(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(me.identitySigRequestText(t)),{bytes:r,recovery:n}=ce(s),i=new we({walletEcdsaCompact:{bytes:r,recovery:n}});return new be({keyBytes:t,signature:i})}}const ge=new a(10**9).mul(10**9);class ve{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(ge)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&K.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await te(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return ae(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(r){const n=t(r.slice(1)),i=s(n),o=i.substring(i.length-40);return e(`0x${o}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return u.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new ve(u.UnsignedPublicKey.decode(e))}}class be extends ve{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(u.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new we(e.signature)}get unsignedKey(){return new ve({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return u.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new be(u.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new we({ecdsaCompact:e.walletEcdsaCompact})),new Ee({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new we({walletEcdsaCompact:s.ecdsaCompact})),new be({keyBytes:e.bytesToSign(),signature:s})}}class Ee extends ve{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new we({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new we(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return u.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(me.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:r}=ce(t);this.signature=new we({ecdsaCompact:{bytes:s,recovery:r}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=n(i(me.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return u.PublicKey.encode(this).finish()}static fromBytes(e){return new Ee(u.PublicKey.decode(e))}}class Ke{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new be(e.identityKey),this.preKey=new be(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return u.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new ke({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=u.SignedPublicKeyBundle.decode(e);return new Ke(t)}static fromLegacyBundle(e){return new Ke({identityKey:be.fromLegacyKey(e.identityKey,!0),preKey:be.fromLegacyKey(e.preKey)})}}class ke{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new Ee(e.identityKey),this.preKey=new Ee(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return u.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=u.PublicKeyBundle.decode(e);return new ke(t)}}class Te extends Error{constructor(e){super(`no pre-key matches: ${oe(e.secp256k1Uncompressed.bytes)}`)}}class Ae{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new he(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new he(e)))}static async generate(e){const t=await he.generate(new me(e)),s=new Ae({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Te(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await he.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new Ke({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(r.length+n.length+o.length);return a.set(r,0),a.set(n,r.length),a.set(o,r.length+n.length),a}encode(){return h.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Ae({identityKey:he.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>he.fromLegacyKey(e)))})}}class Se{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new ye(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new ye(e)))}static async generate(e){const t=ye.generate();e&&await t.publicKey.signWithWallet(e);const s=new Se({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Te(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=ye.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ke({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(r.length+n.length+o.length);return a.set(r,0),a.set(n,r.length),a.set(o,r.length+n.length),a}encode(){return h.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function Ce(e){const t=h.PrivateKeyBundle.decode(e);if(t.v1)return new Se(t.v1);if(t.v2)return new Ae(t.v2);throw new Error("unknown private key bundle version")}class Pe{constructor({eciesBytes:e,signature:t}){if(!e||!e.length)throw new Error("eciesBytes is empty");if(!t)throw new Error("signature is undefined");this.eciesBytes=e,this.signature=new we(t),this.ciphertext=d.SignedEciesCiphertext_Ecies.decode(e)}toBytes(){return d.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await te(this.eciesBytes))}static fromBytes(e){const t=d.SignedEciesCiphertext.decode(e);return new Pe(t)}static async create(e,t){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(e);const s=d.SignedEciesCiphertext_Ecies.encode(e).finish(),r=await t.sign(await te(s));return new Pe({eciesBytes:s,signature:r})}}class Be{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return oe(await te(this.messageEnvelope.message))}async send(){return this.onSend()}}class Ie extends Error{constructor(e,t){super(t),this.code=e}}const Re=e=>{if(e.error)throw new Ie(e.error.code,e.error.message);if(!e.result)throw new Ie(p.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},Ne=(e,t)=>({requests:e.map((e=>{const s=new ke({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),r=t.equals(s);return{payload:e.ciphertext,peerKeys:r?new ke({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:r}}))});class De{constructor(e){this.authorityId=e.authorityId,this.typeId=e.typeId,this.versionMajor=e.versionMajor,this.versionMinor=e.versionMinor}toString(){return`${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`}static fromString(e){const[t,s]=e.split(":"),[r,n]=t.split("/"),[i,o]=s.split(".");return new De({authorityId:r,typeId:n,versionMajor:Number(i),versionMinor:Number(o)})}sameAs(e){return this.authorityId===e.authorityId&&this.typeId===e.typeId}}const Me=new De({authorityId:"brixbit.org",typeId:"fallback",versionMajor:1,versionMinor:0}),_e=new De({authorityId:"brixbit.org",typeId:"text",versionMajor:1,versionMinor:0});var xe;!function(e){e.utf8="UTF-8"}(xe||(xe={}));class Ve{get contentType(){return _e}encode(e){return{type:_e,parameters:{encoding:xe.utf8},content:(new TextEncoder).encode(e)}}decode(e){const t=e.parameters.encoding;if(t&&t!==xe.utf8)throw new Error(`unrecognized encoding ${t}`);return(new TextDecoder).decode(e.content)}fallback(e){}}class Ue{constructor(t,s,r){this.conversationVersion="v1",this.context=void 0,this.peerAddress=e(s),this.client=t,this.createdAt=r}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return B(this.peerAddress,this.client.address)}get ephemeralTopic(){return B(this.peerAddress,this.client.address).replace("/brixbit/0/dm-","/brixbit/0/dmE-")}async messages(e){const t=B(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof ke||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[N(this.peerAddress),N(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const i=await this.client.encodeContent(e,t),o=await this.createMessage(i,r,t?.timestamp),a=o.toBytes(),c={contentTopic:n,message:a,timestampNs:G(o.sent)};return new Be(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a,timestamp:o.sent})))),He.fromV1Message(o,e,t?.contentType||_e,i,n,this))))}streamMessages(e){return W.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await Fe.fromBytes(e),{senderAddress:r,recipientAddress:n}=s;if(!r||!n||!t||B(r,n)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return W.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof ke||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[N(this.peerAddress),N(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||_e,o=await this.client.encodeContent(e,t),a=await this.createMessage(o,r,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a.toBytes(),timestamp:a.sent})))),"unknown"===this.consentState&&await this.allow(),He.fromV1Message(a,e,i,o,n,this)}async decryptBatch(e,t,s=!1){const r=(await this.client.keystore.decryptV1(Ne(e,this.client.publicKeyBundle))).responses,n=[];for(let i=0;i<r.length;i++){const o=r[i],a=e[i];try{const{decrypted:e}=Re(o);n.push(await this.buildDecodedMessage(a,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return n}async buildDecodedMessage(e,t,s){const{content:r,contentType:n,error:i,contentFallback:o}=await this.client.decodeContent(t);return He.fromV1Message(e,r,n,t,s,this,i,o)}async createMessage(e,t,s){return s=s||new Date,Fe.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class qe{constructor(e,t,s,r,n){this.conversationVersion="v2",this.topic=t,this.createdAt=r,this.context=n,this.client=e,this.peerAddress=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/brixbit/0/m","/brixbit/0/mE")}streamEphemeral(e){return W.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return W.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const s=await this.client.encodeContent(e,t),r=await this.createMessage(s,t?.timestamp),n=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:n,message:r.toBytes(),timestamp:r.sent}]);const i=t?.contentType||_e;return"unknown"===this.consentState&&await this.allow(),He.fromV2Message(r,e,i,n,s,this,this.client.address)}async createMessage(e,t){const s={topic:this.topic,createdNs:L(t||new Date)},r=l.MessageHeaderV2.encode(s).finish(),n=await te(X(r,e)),i={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:n,prekeyIndex:0,identityKey:void 0})},o=w.SignedContent.encode(i).finish(),a={v1:void 0,v2:{headerBytes:r,ciphertext:await this.encryptMessage(o,r)}},c=l.Message.encode(a).finish();return Ge.create(a,s,c)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,r=[];for(let n=0;n<s.length;n++){const i=s[n],o=e[n];try{const{decrypted:e}=Re(i);r.push(await this.buildDecodedMessage(o,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return r}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:r}=Re(s[0]);return r}async buildDecodedMessage(e,t){const s=w.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new be(s).verifyKey(new be(t)))throw new Error("pre key not signed by identity key")}(s);const r=await te(X(e.headerBytes,s.payload));if(!new be(s.sender?.preKey).verify(new we(s.signature),r))throw new Error("invalid signature");const n=await new Ke(s.sender).walletSignatureAddress(),{content:i,contentType:o,error:a,contentFallback:c}=await this.client.decodeContent(s.payload);return He.fromV2Message(e,i,o,this.topic,s.payload,this,n,a,c)}async prepareMessage(e,t){const s=await this.client.encodeContent(e,t),r=await this.createMessage(s,t?.timestamp),n=r.toBytes(),i=t?.ephemeral?this.ephemeralTopic:this.topic,o={contentTopic:i,message:n,timestampNs:G(r.sent)};return new Be(o,(async()=>(await this.client.publishEnvelopes([{contentTopic:i,message:n,timestamp:r.sent}]),He.fromV2Message(r,e,t?.contentType||_e,i,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=l.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=l.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return Ge.create(t,s,e.message)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const Oe=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new Q(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new Q(e.v2.ciphertext)];throw new Error("unknown message version")};class Le{constructor(e,t,s){[this.headerBytes,this.ciphertext]=Oe(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class Fe extends Le{constructor(e,t,s,r,n){super(e,t,s),this.conversation=void 0,this.senderAddress=n,this.header=r}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const r=new ke(t.sender).walletSignatureAddress(),n=oe(await te(s));return new Fe(n,s,e,t,r)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new Ee(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(Ne([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:r}=Re(s[0]);return r}static fromBytes(e){const t=l.Message.decode(e),[s]=Oe(t),r=l.MessageHeaderV1.decode(s);if(!r)throw new Error("missing message header");if(!r.sender)throw new Error("missing message sender");if(!r.sender.identityKey)throw new Error("missing message sender identity key");if(!r.sender.preKey)throw new Error("missing message sender pre-key");if(!r.recipient)throw new Error("missing message recipient");if(!r.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!r.recipient.preKey)throw new Error("missing message recipient pre-key");return Fe.create(t,r,e)}static async encode(e,t,s,r,n){const i={sender:s,recipient:r,timestamp:a.fromNumber(n.getTime())},o=l.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:r,headerBytes:o,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=Re(c.responses[0]),h={v1:{headerBytes:o,ciphertext:d},v2:void 0},y=l.Message.encode(h).finish();return Fe.create(h,i,y)}}class Ge extends Le{constructor(e,t,s,r){super(e,t,s),this.header=r}static async create(e,t,s){const r=oe(await te(s));return new Ge(r,s,e,t)}get sent(){return F(this.header.createdNs)}}class He{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:r,conversation:n,contentBytes:i,contentType:o,contentTopic:a,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=r,this.conversation=n,this.contentType=o,this.sent=d,this.error=h,this.content=c,this.contentTopic=a,this.contentBytes=i,this.contentFallback=y}toBytes(){return l.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:L(this.conversation.createdAt),peerAddress:this.conversation.peerAddress},sentNs:L(this.sent)}).finish()}static async fromBytes(e,t){const s=l.DecodedMessage.decode(e),r=s.messageVersion;if("v1"!==r&&"v2"!==r)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:n,contentType:i,error:o,contentFallback:a}=await t.decodeContent(s.contentBytes);return new He({...s,content:n,contentType:i,error:o,messageVersion:r,sent:F(s.sentNs),conversation:$e(s.conversation,t,r),contentFallback:a})}static fromV1Message(e,t,s,r,n,i,o,a){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new He({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:o,contentFallback:a})}static fromV2Message(e,t,s,r,n,i,o,a,c){const{id:d,sent:h}=e;return new He({id:d,messageVersion:"v2",senderAddress:o,sent:h,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:a,contentFallback:c})}}function $e(e,t,s){if("v1"===s)return new Ue(t,e.peerAddress,F(e.createdNs));if("v2"===s)return new qe(t,e.topic,e.peerAddress,F(e.createdNs),e.context);throw new Error(`Unknown conversation version ${s}`)}function je(e,t){return t.decodeContent(e)}class Xe{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:Je,SortDirection:ze}=f,Ye={local:"http://localhost:5555",dev:"https://dev.brixbit.network",production:"https://production.brixbit.network"};var We;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(We||(We={}));class Qe extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new Qe(e.message,e.code)}}const Ze=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),et=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),tt=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=$(e.message)),e):e;class st{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="brixbit-js/11.4.1",e===Ye.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the BRIXBIT 'dev' network. Use 'production' for production messages.\nhttps://github.com/brixbit/brixbit-js#brixbit-production-and-dev-network-environments\n")}async _query(e){try{return await q(Je.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw Qe.fromObject(e)}}_batchQuery(e){return q(Je.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),r=this.headers();r.set("Authorization",`Bearer ${s}`);try{return await q(Je.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:r}],this.maxRetries,100,et)}catch(s){if(et(s)||t>=1)throw Qe.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const r=new AbortController;return(async()=>{for(;;){const n=(new Date).getTime();try{if(await Je.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:r.signal,mode:"cors",headers:this.headers()}),r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await V(1e3),s?.()}catch(e){if(Ze(e)||r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await V(1e3),s?.()}}})(),{unsubscribe:async()=>{r?.abort()}}}async query(e,{direction:t=ze.SORT_DIRECTION_ASCENDING,limit:s}){const r=[];for await(const n of this.queryIteratePages(e,{direction:t,pageSize:s&&s<100?s:100}))for(const e of n)if(r.push(e),s&&r.length===s)return r;return r}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:r,pageSize:n=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=G(t),o=G(s);let a;for(;;){const t={limit:n,direction:r,cursor:a},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:o,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(tt),!s.pagingInfo?.cursor)return;a=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const r=e.slice(s,s+50),n=[];for(const e of r)n.push({contentTopics:[e.contentTopic],startTimeNs:G(e.startTime),endTimeNs:G(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||ze.SORT_DIRECTION_ASCENDING}});const i={requests:n};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),r=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?r.push(t.envelopes.map(tt)):r.push([])}return r}async publish(e){const t=[];for(const{contentTopic:s,message:r,timestamp:n}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!r.length)throw new Error("0 length messages not allowed");const e=n||new Date;t.push({contentTopic:s,timestampNs:G(e),message:Uint8Array.from(r)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(tt(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new Xe(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class rt{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new k,this.keystore=t}get protoJobType(){return function(e){const t={v1:p.JobType.JOB_TYPE_REFRESH_V1,v2:p.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":p.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,r=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),r}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:L(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(p.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(a.fromNumber(0)))return F(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:L(e)})}}const nt=e=>Boolean(e.recipientAddress&&e.senderAddress);class it{constructor(e){this.client=e,this.v1JobRunner=new rt("v1",e.keystore),this.v2JobRunner=new rt("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:ze.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:L(t),topic:B(e,this.client.address),context:void 0}))).filter((e=>x(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),r=new Set(t.map((e=>e.topic)));for(const e of s)r.has(e.topic)||(t.push(e),r.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:ze.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:a.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>x(e.contentTopic)))}),r=[];for(const e of s)try{r.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return r}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new qe(this.client,e.topic,e.peerAddress,F(e.createdNs),e.context)}conversationReferenceToV1(e){return new Ue(this.client,e.peerAddress,F(e.createdNs))}async stream(e){const t=new Set,s=N(this.client.address),r=D(this.client.address),n=[s,r];return W.create(this.client,n,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await Fe.fromBytes(e.message),r=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(r))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new Ue(this.client,r,s.sent)}if(e.contentTopic===r){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=N(this.client.address),s=D(this.client.address),r=new Set([t,s]),n=new Map;for(const e of await this.list())r.add(e.topic),n.set(e.topic,e);const i=(e,t)=>!r.has(e)&&(n.set(e,t),r.add(e),!0),o=await W.create(this.client,Array.from(r.values()),(async e=>{const r=e.contentTopic;if(!r||!e.message)return null;if(r===t){const t=await Fe.fromBytes(e.message);if(!nt(t))return null;const s=this.getPeerAddress(t);return new Ue(this.client,s,t.sent).decodeMessage(e)}if(r===s){return(await this.decodeInvites([e],!0))[0]}const i=n.get(r);if(i instanceof Ue)return i.decodeMessage(e);if(i instanceof qe)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof He&&e.contentTopic===t){const t=new Ue(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(r.values()):void 0}if(e instanceof qe){return i(e.topic,e)?Array.from(r.values()):void 0}}),e),a=async function*(){for await(const e of o)if(e instanceof He&&(yield e),e instanceof qe)for(const t of await e.messages())yield t}();return a.return=async()=>(await(o?.return()),{value:void 0,done:!0}),a}async getIntroductionPeers(e){const t=N(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return Fe.fromBytes(e.message)}),e),r=new Map;for(const e of s){if(!nt(e))continue;const t=this.getPeerAddress(e);if(t){const s=r.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),r.set(t,e.sent)}catch(e){continue}}}return r}async newConversation(e,t){let s=await this.client.getUserContact(e);if(!s)throw new Error(`Recipient ${e} is not on the BRIXBIT network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(s instanceof ke&&!t?.conversationId)return new Ue(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(s instanceof ke||s.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}s instanceof ke&&(s=Ke.fromLegacyBundle(s));const r=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(r=t,n=s.context??void 0,r?.conversationId===n?.conversationId);var r,n},n=(await this.getV2ConversationsFromKeystore()).find(r);return n||this.v2JobRunner.run((async e=>{const n=(await this.updateV2Conversations(e)).find(r);return n||this.createV2Convo(s,t)}))}async createV2Convo(e,t){const s=new Date,{payload:r,conversation:n}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:L(s)});if(!r||!n)throw new Error("Required field not returned from Keystore");const i=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:D(i),message:r,timestamp:s},{contentTopic:D(this.client.address),message:r,timestamp:s}]),await this.client.contacts.allow([i]),this.conversationReferenceToV2(n)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}function ot(e){if(e===w.Compression.COMPRESSION_GZIP)return"gzip";if(e===w.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function at(e,t=1024){let s=0;return new ReadableStream({pull(r){if(s>=e.length)return r.close();let n=s+t;n=n<=e.length?n:e.length,r.enqueue(e.subarray(s,n)),s=n}})}function ct(e,t){let s=0;return new WritableStream({write(r){const n=s+r.length;if(n>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<n;)e.bytes=dt(e.bytes,t);e.bytes.set(r,s),s=n},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function dt(e,t){let s=2*e.length;s>t&&(s=t);const r=new Uint8Array(s);return r.set(e),r}function ht(e){let t;try{t=m.ContactBundle.decode(e)}catch(s){const r=u.PublicKeyBundle.decode(e);t={v1:{keyBundle:new ke(r)},v2:void 0}}if(t.v1?.keyBundle)return new ke(t.v1.keyBundle);if(t.v2?.keyBundle)return new Ke(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function yt(e){return e instanceof ke?m.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():m.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}class ut{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new ut({walletAddr:e,createdNs:L(t)})}static fromBytes(e){const t=g.AuthData.decode(e);return new ut(t)}toBytes(){return g.AuthData.encode(this).finish()}}class pt{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=ut.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return g.Token.encode(this).finish()}static fromBytes(e){return new pt(g.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class lt{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=ut.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),r=s(t),i=await this.identityKey.sign(n(r));return new pt(g.Token.fromPartial({identityKey:u.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:y.Signature.fromPartial(i)}))}}class wt{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof pt?e:new pt(e))(await this.keystore.createAuthToken({timestampNs:e?L(e):void 0}))}}var ft;!function(e){e[e.none=0]="none",e[e.brixbitTopicStore=1]="brixbitTopicStore"}(ft||(ft={}));const mt=ft.none;class gt{static createConfiguration(){return{type:mt,version:0}}constructor(e){this.configuration=e}get backupType(){return mt}}const vt=ft.brixbitTopicStore;class bt{static createConfiguration(e){return{type:vt,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return vt}}async function Et(e,t){const s=await async function(e,t){let s;switch((await t()).type){case ft.none:s=gt.createConfiguration();break;case ft.brixbitTopicStore:s=bt.createConfiguration(e)}return s}(e,t);switch(s.type){case ft.none:return new gt(s);case ft.brixbitTopicStore:return new bt(s)}}class Kt extends Error{}class kt{constructor({topic:e,context:t,aes256GcmHkdfSha256:s}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s}static createRandom(e){const t=I(Buffer.from(Z.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),s=Z.getRandomValues(new Uint8Array(32));return new kt({topic:t,aes256GcmHkdfSha256:{keyMaterial:s},context:e})}toBytes(){return v.InvitationV1.encode(this).finish()}static fromBytes(e){return new kt(v.InvitationV1.decode(e))}}class Tt{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new Ke(e),this.recipient=new Ke(t),this.createdNs=s}toBytes(){return v.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new Tt(v.SealedInvitationHeaderV1.decode(e))}}class At{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new Q(t)}get header(){return this._header||(this._header=Tt.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const r=await re(this.ciphertext,s,this.headerBytes);return this._invitation=kt.fromBytes(r),this._invitation}toBytes(){return v.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new At(v.SealedInvitationV1.decode(e))}}class St{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new At(e)}toBytes(){return v.SealedInvitation.encode(this).finish()}static fromBytes(e){return new St(v.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=St.fromBytes(e.message),s=a.fromString(e.timestampNs),r=t.v1?.header.createdNs;if(!r||!r.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:r}){const n=new Tt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:L(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),o=r.toBytes(),a=await se(o,i,n);return new St({v1:{headerBytes:n,ciphertext:a}})}}const Ct=async(e,t,s,r)=>se(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),r),Pt=(e,t,s)=>se(e,t,s),Bt=(e,t)=>e instanceof Ie?e:new Ie(t,e.message),It=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:Bt(e,s)}}}))),Rt=e=>e instanceof ke?e:new ke(e),Nt=(e,t,s)=>{for(const s of t)if(!e[s])throw new Ie(p.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new Ie(p.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},Dt=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new Ie(p.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},Mt=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t});class _t{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new k,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new _t(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?function(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,function(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,r]of Object.entries(e.topics))t.set(s,r);return t})(p.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...r}=s;this.topicMap.has(e)||(this.topicMap.set(e,r),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return p.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class xt extends _t{static async create(e){const t=new xt(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const Vt=new(0,T.ec)("secp256k1"),Ut=Z.subtle,qt=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),Ot=Buffer.alloc(32,0);function Lt(e,t){if(!e)throw new Error(t||"Assertion failed")}function Ft(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(Ot)>0&&e.compare(qt)<0);var t}function Gt(e){const t=new Uint8Array(e);return Z.getRandomValues(t),Buffer.from(t)}async function Ht(e){const t=await Ut.digest("SHA-512",e);return Buffer.from(t)}function $t(e){return function(t,s,r){return new Promise((function(n){return Ut.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const n={name:"AES-CBC",iv:t};return Ut[e](n,s,r)})).then((function(e){n(Buffer.from(new Uint8Array(e)))}))}))}}const jt=$t("encrypt"),Xt=$t("decrypt");async function Jt(e,t){const s=await Ut.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await Ut.sign({name:"HMAC",hash:"SHA-256"},s,t))}function zt(e){return Lt(32===e.length,"Bad private key"),Lt(Ft(e),"Bad private key"),Buffer.from(Vt.keyFromPrivate(e).getPublic("array"))}function Yt(e,t){return new Promise((function(s){Lt(Buffer.isBuffer(e),"Bad private key"),Lt(Buffer.isBuffer(t),"Bad public key"),Lt(32===e.length,"Bad private key"),Lt(Ft(e),"Bad private key"),Lt(65===t.length||33===t.length,"Bad public key"),65===t.length&&Lt(4===t[0],"Bad public key"),33===t.length&&Lt(2===t[0]||3===t[0],"Bad public key");const r=Vt.keyFromPrivate(e),n=Vt.keyFromPublic(t),i=r.derive(n.getPublic());s(Buffer.from(i.toArray()))}))}async function Wt(e,t){const s=await Yt(e,t.ephemeralPublicKey),r=await Ht(s),n=r.slice(0,32),i=r.slice(32),o=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return Lt(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let r=0;r<e.length;r++)s|=e[r]^t[r];return 0===s}(await Jt(e,t),s)}(i,o,t.mac),"Bad mac"),Xt(t.iv,n,t.ciphertext)}async function Qt(e,t){const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return A(s,r,t)}async function Zt(e,t){const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return S(s,r,t)}const{ErrorCode:es}=p,ts=(new TextEncoder).encode("__BRIXBIT__INVITATION__SALT__BRIXBIT__");class ss{constructor(e,t,s,r){this.v1Keys=e,this.v2Keys=Ae.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.authenticator=new lt(e.identityKey),this.jobStatePersistence=r}static async create(e,t){return new ss(e,await xt.create(t),await _t.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await It(e.requests,(async e=>{Nt(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:r,isSender:n}=e,i=await(async(e,t,s,r,n)=>re(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!n),r))(this.v1Keys,Rt(s),t,r,n);return{decrypted:i}}),p.ErrorCode.ERROR_CODE_UNSPECIFIED);return p.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await It(e.requests,(async e=>{Nt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new Ie(p.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=await((e,t,s)=>re(e,t,s))(t,Dt(n.invitation),s);return{decrypted:i}}),es.ERROR_CODE_UNSPECIFIED);return p.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await It(e.requests,(async e=>{Nt(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:r}=e;return{encrypted:await Ct(this.v1Keys,Rt(t),s,r)}}),es.ERROR_CODE_UNSPECIFIED);return p.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?F(e):void 0)}async selfEncrypt(e){const t=await It(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Ie(es.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await Qt(this.v1Keys.identityKey,t)}}),es.ERROR_CODE_INVALID_INPUT);return p.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await It(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Ie(es.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await Zt(this.v1Keys.identityKey,t)}}),es.ERROR_CODE_INVALID_INPUT);return p.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){const t=e.secp256k1.bytes;return C(t)}(this.v1Keys.identityKey);return p.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await It(e.requests,(async e=>{Nt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new Ie(es.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return{encrypted:await Pt(t,Dt(n.invitation),s)}}),es.ERROR_CODE_INVALID_INPUT);return p.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await It(e.requests,(async({payload:e,timestampNs:s})=>{const r=St.fromBytes(e);if(r.v1){if(!r.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=r.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),n=await r.v1.getInvitation(this.v2Keys),i={invitation:n,createdNs:r.v1.header.createdNs,peerAddress:e?await r.v1.header.recipient.walletSignatureAddress():await r.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:n.topic}),{conversation:Mt(i)}}}),es.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),p.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{Nt(e,["recipient"],[]);const s=F(e.createdNs),r=(t=e.recipient)instanceof Ke?t:new Ke(t),n=await this.getAccountAddress(),i=await r.walletSignatureAddress(),o=await this.v2Keys.sharedSecret(r,this.v2Keys.getCurrentPreKey().publicKey,n<i),a=[n,i].sort(),c=(e.context?.conversationId||"")+a.join(),d=(new TextEncoder).encode(c),h=oe(await Jt(Buffer.from(o),Buffer.from(d))),y=["0",...a].join("|"),u=(new TextEncoder).encode(y),l=await async function(e,t){const s=await Z.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return Z.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:ts,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(o,u),w=new Uint8Array(await Z.subtle.exportKey("raw",l)),f=new kt({topic:I(h),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context}),m=await St.createV1({sender:this.v2Keys,recipient:r,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await r.walletSignatureAddress()};return await this.v2Store.add([g]),p.CreateInviteResponse.fromPartial({conversation:Mt(g),payload:m.toBytes()})}catch(e){throw Bt(e,es.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){Nt(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:r}=e;let n;if(s)n=this.v1Keys.identityKey;else{if(void 0===r||!Number.isInteger(r))throw new Ie(es.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(n=this.v1Keys.preKeys[r],!n)throw new Ie(es.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return n.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:B(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>Mt(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),p.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===p.JobType.JOB_TYPE_UNSPECIFIED)throw new Ie(es.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return p.GetRefreshJobResponse.fromPartial({lastRunNs:t||a.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:B(e.peerAddress,this.walletAddress),context:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return a.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}}class rs{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:f.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return M(e)}}class ns{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new ns(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class is{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class os extends ns{static create(){return new ns(new is)}}class as{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}class cs{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=zt(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const r=s?.iv||Gt(16);let n=s?.ephemPrivateKey||Gt(32);for(;!Ft(n);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");n=Gt(32)}const i=zt(n),o=await Ht(await Yt(n,e)),a=o.slice(0,32),c=o.slice(32),d=await jt(r,a,t),h=Buffer.concat([r,i,d]);return{iv:r,ephemeralPublicKey:i,ciphertext:d,mac:await Jt(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await Wt(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await Pe.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=Pe.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}const ds=async(e,t)=>{if(!e.persistConversations)return os.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),r=`brixbit/${e.env}/${s}/`;const n=e.basePersistence,i=!e.disablePersistenceEncryption;return new as(r,i?new cs(n,t.identityKey):n)},hs="key_bundle";class ys{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(t){let s=await this.signer.getAddress();return s=e(s),`${s}/${t}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(hs));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(hs),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new lt(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,t){const s=e.encode(),r=Z.getRandomValues(new Uint8Array(32)),i=ps(r),a=await t.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const c=await t.signMessage(i);if(!o({address:a,message:i,signature:c}))throw new Error("invalid signature");const d=n(c),y=await se(s,d);return h.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:r,ciphertext:y}}).finish()}async fromEncryptedBytes(e,t){const[s,r]=function(e){try{const t=h.EncryptedPrivateKeyBundle.decode(e);if(t.v1)return[t.v1,!1]}catch(t){return[h.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(t);if(!s.walletPreKey)throw new Error("missing wallet pre-key");if(!s.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=n(await e.signMessage(ps(s.walletPreKey)));try{const e=new Q(s.ciphertext),t=await re(e,i),[n,o]=us(t);return[n,r||o]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let n=i.slice(0,i.length-1);n=t<27?new Uint8Array([...n,t+27]):new Uint8Array([...n,t-27]);const o=new Q(s.ciphertext),a=await re(o,n),[c,d]=us(a);return[c,r||d]}}}function us(e){try{const t=Ce(e);if(t instanceof Ae)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(t){const s=h.PrivateKeyBundleV1.decode(e);return[new Se(s),!0]}}function ps(e){return`BRIXBIT : Enable Identity\n${oe(e)}\n\nFor more info: https://brixbit.org/signatures/`}class ls{async newKeystore(e,t,s){if(!s)throw new Kt("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const r=await Se.generate(s),n=new ys(s,new rs(t),e.preEnableIdentityCallback);return await n.storePrivateKeyBundle(r),ss.create(r,await ds(e,r))}}class ws{async newKeystore(e,t,s){if(!s)throw new Kt("No wallet provided");const r=new ys(s,new rs(t),e.preEnableIdentityCallback),n=await r.loadPrivateKeyBundle();if(!n)throw new Kt("No keys found");return ss.create(n,await ds(e,n))}}class fs{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new Kt("No private key override provided");const s=Ce(t);if(s instanceof Ae)throw new Error("V2 private key bundle found. Only V1 supported");return ss.create(s,await ds(e,s))}}function ms(){return window.ethereum}const{GetKeystoreStatusResponse_KeystoreStatus:gs,InitKeystoreRequest:vs,InitKeystoreResponse:bs,GetKeystoreStatusRequest:Es,GetKeystoreStatusResponse:Ks}=p;async function ks(e,t,s,r,n){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=j(e,0,e.length)}const o=await async function(e,t,s,r){const n={meta:s};"string"==typeof t&&(n.req=t);const i=await(ms()?.request({method:"wallet_invokeSnap",params:{snapId:r,request:{method:e,params:n}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,r,n);if(Array.isArray(o))throw new Error("Unexpected array response");return t.res.decode($(o))}async function Ts(){const e=ms();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function As(e,t){try{const s=await async function(){return await(ms()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(r=s.version,n=t,!r||!n||J(r).major===J(n).major));var r,n})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const Ss={req:Es,res:Ks};const Cs={req:vs,res:bs};const Ps={decryptV1:{req:p.DecryptV1Request,res:p.DecryptResponse},decryptV2:{req:p.DecryptV2Request,res:p.DecryptResponse},encryptV1:{req:p.EncryptV1Request,res:p.EncryptResponse},encryptV2:{req:p.EncryptV2Request,res:p.EncryptResponse},saveInvites:{req:p.SaveInvitesRequest,res:p.SaveInvitesResponse},createInvite:{req:p.CreateInviteRequest,res:p.CreateInviteResponse},createAuthToken:{req:p.CreateAuthTokenRequest,res:g.Token},signDigest:{req:p.SignDigestRequest,res:y.Signature},getPublicKeyBundle:{req:null,res:u.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:h.PrivateKeyBundleV1},saveV1Conversations:{req:p.SaveV1ConversationsRequest,res:p.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:p.GetConversationsResponse},getV2Conversations:{req:null,res:p.GetConversationsResponse},getRefreshJob:{req:p.GetRefreshJobRequest,res:p.GetRefreshJobResponse},setRefreshJob:{req:p.SetRefeshJobRequest,res:p.SetRefreshJobResponse},selfEncrypt:{req:p.SelfEncryptRequest,res:p.SelfEncryptResponse},selfDecrypt:{req:p.SelfDecryptRequest,res:p.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:p.GetPrivatePreferencesTopicIdentifierResponse}},Bs={...Ps,getKeystoreStatus:{req:p.GetKeystoreStatusRequest,res:p.GetKeystoreStatusResponse},initKeystore:{req:p.InitKeystoreRequest,res:p.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:Is}=p;class Rs{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new Kt("No wallet provided");if(!await Ts())throw new Kt("MetaMask with Snaps not detected");const r=await s.getAddress(),n=e.env,i=await As(this.snapId,this.snapVersion);if(i&&!z(this.snapVersion,i.version)||await async function(e,t={}){await(ms()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const r=await async function(e,t){const s=await ks("getKeystoreStatus",Ss,{walletAddress:e.walletAddress},e,t);if([gs.KEYSTORE_STATUS_UNSPECIFIED,gs.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(r===Is.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(r,n,this.snapId)){const r=await async function(e,t,s){if(e.privateKeyOverride){const t=Ce(e.privateKeyOverride);if(!(t instanceof Se))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const r=new ws;try{const n=await r.newKeystore(e,t,s);return new Se(await n.getPrivateKeyBundle())}catch(r){if(r instanceof Kt)return async function(e,t,s){const r=new ls,n=await r.newKeystore(e,t,s);return new Se(await n.getPrivateKeyBundle())}(e,t,s);throw r}}(e,t,s)}(e,t,s);await async function(e,t,s){const r=e.identityKey.publicKey.walletSignatureAddress(),n=await ks("initKeystore",Cs,{v1:e},{walletAddress:r,env:t},s);if(n.error)throw new Ie(n.error.code,n.error.message)}(r,n,this.snapId)}return function(e,t,s){const r={},n={walletAddress:e,env:t};for(const[e,t]of Object.entries(Bs))r[e]=async r=>t.req?ks(e,t,r,n,s):ks(e,t,void 0,n,s);return{...r,getAccountAddress:async()=>e}}(r,n,this.snapId)}}class Ns{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new Ns(e,"address",t)}}class Ds{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=Ns.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=Ns.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=Ns.fromAddress(e);return this.entries.get(t.key)??"unknown"}async getIdentifier(){if(!this._identifier){const{identifier:e}=await this.client.keystore.getPrivatePreferencesTopicIdentifier();this._identifier=e}return this._identifier}async decodeMessages(e){const{responses:t}=await this.client.keystore.selfDecrypt({requests:e.map((e=>({payload:e})))});return t.reduce(((e,t)=>t.result?.decrypted?e.concat(b.PrivatePreferencesAction.decode(t.result.decrypted)):e),[])}processActions(e,t){const s=[];return e.forEach((e=>{e.allow?.walletAddresses.forEach((e=>{s.push(this.allow(e))})),e.block?.walletAddresses.forEach((e=>{s.push(this.deny(e))}))})),t&&(this.lastEntryTimestamp=H(t)),s}async stream(e){const t=await this.getIdentifier(),s=_(t);return W.create(this.client,[s],(async e=>{if(!e.message)return;const t=await this.decodeMessages([e.message]);return this.processActions(t,e.timestampNs),t[0]}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.getIdentifier(),s=_(t);let r;const n=await this.client.listEnvelopes(s,(async({message:e,timestampNs:t})=>(t&&(r=t),e)),{startTime:e}),i=await this.decodeMessages(n);return this.processActions(i,r)}async publish(e){const t=await this.getIdentifier(),s=e.reduce(((e,t)=>{if("address"===t.entryType){const s={allow:"allowed"===t.permissionType?{walletAddresses:[t.value]}:void 0,block:"denied"===t.permissionType?{walletAddresses:[t.value]}:void 0};return e.concat(b.PrivatePreferencesAction.encode(s).finish())}return e}),[]),{responses:r}=await this.client.keystore.selfEncrypt({requests:s.map((e=>({payload:e})))}),n=r.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),i=_(t),o=new Date,a=n.map((e=>({contentTopic:i,message:e,timestamp:o})));await this.client.publishEnvelopes(a),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class Ms{constructor(e){this.addresses=new Set,this.consentList=new Ds(e),this.client=e,this.jobRunner=new rt("user-preferences",e.keystore)}async loadConsentList(e){return this.jobRunner.run((async t=>this.consentList.load(e??t)))}async refreshConsentList(){return this.consentList.reset(),await this.jobRunner.resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return this.consentList.stream(e)}get lastConsentListEntryTimestamp(){return this.consentList.lastEntryTimestamp}setConsentListEntries(e){e.length&&(this.consentList.reset(),e.forEach((e=>{"allowed"===e.permissionType&&this.consentList.allow(e.value),"denied"===e.permissionType&&this.consentList.deny(e.value)})))}isAllowed(e){return"allowed"===this.consentList.state(e)}isDenied(e){return"denied"===this.consentList.state(e)}consentState(e){return this.consentList.state(e)}async allow(e){await this.consentList.publish(e.map((e=>Ns.fromAddress(e,"allowed"))))}async deny(e){await this.consentList.publish(e.map((e=>Ns.fromAddress(e,"denied"))))}}const{Compression:_s}=w,xs=104857600;class Vs{constructor(e,t,s,r){this.knownPublicKeyBundles=new Map,this.keystore=r,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new it(this),this._codecs=new Map,this._maxContentSize=xs,this.apiClient=t,this._backupClient=s,this.contacts=new Ms(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return Ke.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=Y(e),r=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new Ve],maxContentSize:xs,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?ns.create():os.create(),disablePersistenceEncryption:!1,keystoreProviders:Ls(),apiClientFactory:Us};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Rs("npm:@brixbit/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),n=r.apiClientFactory(r),i=await async function(e,t,s){for(const r of e.keystoreProviders)try{return await r.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof Kt)continue;throw e}throw new Error("No keystore providers available")}(r,n,s),o=new ke(await i.getPublicKeyBundle()),a=o.walletSignatureAddress();n.setAuthenticator(new wt(i));const c=await Vs.setupBackupClient(a,r.env),d=new Vs(o,n,c,i);return await d.init(r),d}static async getKeys(e,t){const s=await Vs.create(Y(e),t),r=await s.keystore.getPrivateKeyBundle();return new Se(r).encode()}static isSnapsReady(){return Ts()}static async setupBackupClient(e,t){return Et(e,(async()=>Promise.resolve({type:"local"===t?ft.brixbitTopicStore:ft.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await qs(this.apiClient,this.address);t&&t instanceof Ke&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:R(this.address),message:yt(t)}])}async getUserContact(t){t=e(t);const s=this.knownPublicKeyBundles.get(t);if(s)return s;const r=await qs(this.apiClient,t);return r&&this.knownPublicKeyBundles.set(t,r),r}async getUserContacts(t){const s=t.map((t=>e(t))),r=new Map,n=[];for(const e of s){const t=this.knownPublicKeyBundles.get(e);t?r.set(e,t):(r.set(e,void 0),n.push(e))}const i=await Os(this.apiClient,n);for(let e=0;e<i.length;e++){const t=n[e],s=i[e];r.set(t,s),s&&this.knownPublicKeyBundles.set(t,s)}return s.map((e=>r.get(e)))}forgetContact(t){t=e(t),this.knownPublicKeyBundles.delete(t)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(t,s){const r=s?.apiUrl||Ye[s?.env||"dev"],n=new st(r,{appVersion:s?.appVersion});if(Array.isArray(t)){const s=t.map((t=>e(t)));return(await Os(n,s)).map((e=>!!e))}try{t=e(t)}catch(e){return!1}return void 0!==await qs(n,t)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||_e,r=this.codecFor(s);if(!r)throw new Error("unknown content type "+s);const n=r.encode(e,this),i=r.fallback(e);return i&&(n.fallback=i),"number"==typeof t?.compression&&n.content.length>=10&&(n.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await at(e.content).pipeThrough(new CompressionStream(ot(e.compression))).pipeTo(ct(t,e.content.length+1e3)),e.content=t.bytes}(n),w.EncodedContent.encode(n).finish()}async decodeContent(e){const t=w.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const r=new De(t.type);let n;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await at(e.content).pipeThrough(new DecompressionStream(ot(e.compression))).pipeTo(ct(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(r);return i?s=i.decode(t,this):n=new Error("unknown content type "+r),{content:s,contentType:r,error:n,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(D(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:r,endTime:n,limit:i}=s,o=await this.apiClient.query({contentTopic:e,startTime:r,endTime:n},{direction:s.direction||f.SortDirection.SORT_DIRECTION_ASCENDING,limit:i}),a=[];for(const e of o)if(e.message)try{const s=await t(e);a.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return a}listEnvelopesPaginated(e,t,s){return O(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function Us(e){const t=e.apiUrl||Ye[e.env];return new st(t,{appVersion:e.appVersion})}async function qs(e,t){const s=e.queryIterator({contentTopic:R(t)},{pageSize:5,direction:ze.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=ht(e.message);let r;try{r=await(s?.walletSignatureAddress())}catch(e){r=void 0}if(r?.toLowerCase()===t.toLowerCase())return s}}async function Os(e,t){const s=t.map(R),r=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:ze.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=r[t];if(s)for(const t of s)if(t.message)try{const s=ht(t.message),r=await(s?.walletSignatureAddress());if(e.toLowerCase()===r.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function Ls(){return[new fs,new ws,new ls]}const Fs=new De({authorityId:"brixbit.org",typeId:"composite",versionMajor:1,versionMinor:0});class Gs{get contentType(){return Fs}encode(e,t){const s=this.toProto(e,t);let r;r=s.composite?s.composite:{parts:[s]};const n=E.Composite.encode(r).finish();return{type:Fs,parameters:{},content:n}}decode(e,t){return this.fromProto({composite:E.Composite.decode(e.content),part:void 0},t)}toProto(e,t){if("type"in e){const s=t.codecFor(e.type);if(!s)throw new Error(`missing codec for part type ${e.type}`);return{part:s.encode(e.content,t),composite:void 0}}const s=new Array;for(const r of e.parts)s.push(this.toProto(r,t));return{composite:{parts:s},part:void 0}}fromProto(e,t){if(e.part){if(!e.part.type)throw new Error("missing part content type");const s=new De(e.part.type),r=t.codecFor(s);if(!r)throw new Error(`missing codec for part type ${s}`);return{type:s,content:r.decode(e.part,t)}}if(!e.composite)throw new Error("invalid composite");const s=new Array;for(const r of e.composite.parts)s.push(this.fromProto(r,t));return{parts:s}}fallback(e){}}export{Ye as ApiUrls,Xe as AuthCache,ns as BrowserStoragePersistence,Q as Ciphertext,Vs as Client,Gs as CompositeCodec,_s as Compression,Ns as ConsentListEntry,Fs as ContentTypeComposite,Me as ContentTypeFallback,De as ContentTypeId,_e as ContentTypeText,Ue as ConversationV1,qe as ConversationV2,it as Conversations,He as DecodedMessage,cs as EncryptedPersistence,st as HttpApiClient,ss as InMemoryKeystore,os as InMemoryPersistence,kt as InvitationV1,ls as KeyGeneratorKeystoreProvider,lt as LocalAuthenticator,Fe as MessageV1,Ge as MessageV2,ws as NetworkKeystoreProvider,as as PrefixedPersistence,ye as PrivateKey,Se as PrivateKeyBundleV1,Ae as PrivateKeyBundleV2,Ee as PublicKey,ke as PublicKeyBundle,St as SealedInvitation,we as Signature,be as SignedPublicKey,Ke as SignedPublicKeyBundle,Rs as SnapProvider,ze as SortDirection,fs as StaticKeystoreProvider,W as Stream,Ve as TextCodec,P as buildContentTopic,B as buildDirectMessageTopic,I as buildDirectMessageTopicV2,R as buildUserContactTopic,N as buildUserIntroTopic,D as buildUserInviteTopic,M as buildUserPrivateStoreTopic,L as dateToNs,ht as decodeContactBundle,je as decodeContent,re as decrypt,Ls as defaultKeystoreProviders,se as encrypt,H as fromNanoString,Ps as keystoreApiDefs,O as mapPaginatedStream,F as nsToDate,q as retry,Bs as snapKeystoreApiDefs,G as toNanoString};
//# sourceMappingURL=index.js.map
