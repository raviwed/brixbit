import{getAddress as e,bytesToHex as t,keccak256 as s,hexToSignature as r,hexToBytes as n,hashMessage as i,verifyMessage as o}from"viem";import a from"long";import{fetcher as c,ciphertext as d,privateKey as h,signature as y,publicKey as u,keystore as p,message as l,content as w,messageApi as f,contact as m,authn as g,invitation as v,privatePreferences as b,composite as E}from"@brixbit/proto";import*as K from"@noble/secp256k1";import{Mutex as k}from"async-mutex";import T from"elliptic";import A,{user_preferences_encrypt as S,user_preferences_decrypt as C,generate_private_preferences_topic as P}from"@brixbit/user-preferences-bindings-wasm/web";const B=e=>`/brixbit/0/${e}/proto`,I=(t,s)=>{const r=[e(t),e(s)];return r.sort(),B(`dm-${r.join("-")}`)},R=e=>B(`m-${e}`),N=t=>B(`contact-${e(t)}`),D=t=>B(`intro-${e(t)}`),M=t=>B(`invite-${e(t)}`),_=e=>B(`privatestore-${e}`),x=e=>B(`userpreferences-${e}`),V=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const r=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(r)}return!1},U=e=>new Promise((t=>setTimeout(t,e))),q=e=>!!e;async function O(e,t,s,r,n=q,i=1){const o="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!n(i)||o>s)throw i;return await U(r),O(e,t,s,r,n,o+1)}}async function*L(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),r=[];for(const t of e)"fulfilled"===t.status?r.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield r}}function F(e){return a.fromNumber(e.valueOf()).multiply(1e6)}function G(e){return new Date(e.divide(1e6).toNumber())}const H=e=>e&&F(e).toString(),$=e=>{if(e)return G(a.fromString(e))},{b64Decode:j,b64Encode:X}=c;function J(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function z(e){const[t,s,...r]=e.split(".");return{major:Number(t),minor:Number(s),patch:r.join(".")}}function Y(e,t){if(!e||!t)return!1;const s=z(e),r=z(t);return s.major!==r.major?s.major>r.major:s.minor!==r.minor?s.minor>r.minor:!(!s.patch||!r.patch)&&function(e,t){const[s,r]=e.split("-"),[n,i]=t.split("-");if(Number(s)!==Number(n))return Number(s)>Number(n);if(!r||!i)return!1;const[o,a]=r.split("."),[c,d]=i.split(".");if(o!==c)return!0;return Number(a)>Number(d)}(s.patch,r.patch)}function W(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}class Q{constructor(e,t,s,r,n){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,r),this.onConnectionLost=n}newMessageCallback(e,t){return async s=>{if(s.message)try{const r=await e(s);if(!r)return;if(t){const e=t(r);e&&this.resubscribeToTopics(e)}const n=this.resolvers.pop();n?n({value:r}):this.messages.unshift(r)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,r,n){const i=new Q(e,t,s,r,n);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}class Z{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return d.Ciphertext.encode(this).finish()}static fromBytes(e){return new Z(d.Ciphertext.decode(e))}}const ee=window.crypto,te=(new Uint8Array).buffer;async function se(e){return new Uint8Array(await ee.subtle.digest("SHA-256",e))}async function re(e,t,s){const r=ee.getRandomValues(new Uint8Array(32)),n=ee.getRandomValues(new Uint8Array(12)),i=await oe(t,r),o=await ee.subtle.encrypt(ie(n,s),i,e);return new Z({aes256GcmHkdfSha256:{payload:new Uint8Array(o),hkdfSalt:r,gcmNonce:n}})}async function ne(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const r=await oe(t,e.aes256GcmHkdfSha256.hkdfSalt),n=await ee.subtle.decrypt(ie(e.aes256GcmHkdfSha256.gcmNonce,s),r,e.aes256GcmHkdfSha256.payload);return new Uint8Array(n)}function ie(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function oe(e,t){const s=await ee.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return ee.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:te},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}const ae=K.utils.bytesToHex;function ce(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function de(e){const t=r(e),s=n(t.r),i=n(t.s);let o=Number(t.v);0!==o&&1!==o||(o+=27);const a=1-o%2,c=new Uint8Array(64);return c.set(s),c.set(i,s.length),{bytes:c,recovery:a}}function he(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class ye{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(he(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new Ee(e.publicKey)}static async generate(e){const t={bytes:K.utils.randomPrivateKey()},s=a.fromNumber((new Date).getTime()).mul(1e6),r=new be({secp256k1Uncompressed:{bytes:K.getPublicKey(t.bytes)},createdNs:s}),n=await e.signKey(r);return new ye({secp256k1:t,createdNs:s,publicKey:n})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await K.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new fe({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await se(t),r=await this.sign(s);return new Ee({keyBytes:t,signature:r})}static async signerKey(e,t){return we(await se(e.bytesToSign()),t)}sharedSecret(e){return K.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return re(e,this.sharedSecret(t),s)}decrypt(e,t,s){return ne(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return ce(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return h.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return ce(K.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new ye(h.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new ye({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:Ee.fromLegacyKey(e.publicKey,t)})}}class ue{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(he(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new Ke(e.publicKey)}static generate(){const e={bytes:K.utils.randomPrivateKey()},t=a.fromNumber((new Date).getTime());return new ue({secp256k1:e,timestamp:t,publicKey:new Ke({secp256k1Uncompressed:{bytes:K.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await K.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new fe({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await se(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return K.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return re(e,this.sharedSecret(t),s)}decrypt(e,t,s){return ne(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return ce(K.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return h.PrivateKey.encode(this).finish()}static fromBytes(e){return new ue(h.PrivateKey.decode(e))}}function pe(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function le(e,t){return e.recovery===t.recovery&&ce(e.bytes,t.bytes)}function we(e,t){const s=K.recoverPublicKey(e,t.bytes,t.recovery);return s?new be({secp256k1Uncompressed:{bytes:s},createdNs:a.fromNumber(0)}):void 0}class fe{constructor(e){if(e.ecdsaCompact)pe(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");pe(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?ye.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?ge.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=K.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=K.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new Ke({secp256k1Uncompressed:{bytes:t},timestamp:a.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?le(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&le(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return y.Signature.encode(this).finish()}static fromBytes(e){return new fe(y.Signature.decode(e))}}var me;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(me||(me={}));class ge{constructor(e){this.wallet=e}static identitySigRequestText(e){return`BRIXBIT : Create Identity\n${ae(e)}\n\nFor more info: https://brixbit.org/signatures/`}static signerKey(e,t){return we(n(i(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(ge.identitySigRequestText(t)),{bytes:r,recovery:n}=de(s),i=new fe({walletEcdsaCompact:{bytes:r,recovery:n}});return new Ee({keyBytes:t,signature:i})}}const ve=new a(10**9).mul(10**9);class be{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(ve)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&K.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await se(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return ce(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(r){const n=t(r.slice(1)),i=s(n),o=i.substring(i.length-40);return e(`0x${o}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return u.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new be(u.UnsignedPublicKey.decode(e))}}class Ee extends be{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(u.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new fe(e.signature)}get unsignedKey(){return new be({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return u.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new Ee(u.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new fe({ecdsaCompact:e.walletEcdsaCompact})),new Ke({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new fe({walletEcdsaCompact:s.ecdsaCompact})),new Ee({keyBytes:e.bytesToSign(),signature:s})}}class Ke extends be{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new fe({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new fe(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return u.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(ge.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:r}=de(t);this.signature=new fe({ecdsaCompact:{bytes:s,recovery:r}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=n(i(ge.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return u.PublicKey.encode(this).finish()}static fromBytes(e){return new Ke(u.PublicKey.decode(e))}}class ke{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new Ee(e.identityKey),this.preKey=new Ee(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return u.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new Te({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=u.SignedPublicKeyBundle.decode(e);return new ke(t)}static fromLegacyBundle(e){return new ke({identityKey:Ee.fromLegacyKey(e.identityKey,!0),preKey:Ee.fromLegacyKey(e.preKey)})}}class Te{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new Ke(e.identityKey),this.preKey=new Ke(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return u.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=u.PublicKeyBundle.decode(e);return new Te(t)}}class Ae extends Error{constructor(e){super(`no pre-key matches: ${ae(e.secp256k1Uncompressed.bytes)}`)}}class Se{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new ye(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new ye(e)))}static async generate(e){const t=await ye.generate(new ge(e)),s=new Se({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Ae(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await ye.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ke({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(r.length+n.length+o.length);return a.set(r,0),a.set(n,r.length),a.set(o,r.length+n.length),a}encode(){return h.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Se({identityKey:ye.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>ye.fromLegacyKey(e)))})}}class Ce{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new ue(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new ue(e)))}static async generate(e){const t=ue.generate();e&&await t.publicKey.signWithWallet(e);const s=new Ce({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Ae(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=ue.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new Te({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let r,n,i;s?(i=this.findPreKey(t),r=i.sharedSecret(e.identityKey),n=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),r=this.identityKey.sharedSecret(e.preKey),n=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(r.length+n.length+o.length);return a.set(r,0),a.set(n,r.length),a.set(o,r.length+n.length),a}encode(){return h.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function Pe(e){const t=h.PrivateKeyBundle.decode(e);if(t.v1)return new Ce(t.v1);if(t.v2)return new Se(t.v2);throw new Error("unknown private key bundle version")}class Be{constructor({eciesBytes:e,signature:t}){if(!e||!e.length)throw new Error("eciesBytes is empty");if(!t)throw new Error("signature is undefined");this.eciesBytes=e,this.signature=new fe(t),this.ciphertext=d.SignedEciesCiphertext_Ecies.decode(e)}toBytes(){return d.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await se(this.eciesBytes))}static fromBytes(e){const t=d.SignedEciesCiphertext.decode(e);return new Be(t)}static async create(e,t){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(e);const s=d.SignedEciesCiphertext_Ecies.encode(e).finish(),r=await t.sign(await se(s));return new Be({eciesBytes:s,signature:r})}}class Ie{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return ae(await se(this.messageEnvelope.message))}async send(){return this.onSend()}}class Re extends Error{constructor(e,t){super(t),this.code=e}}const Ne=e=>{if(e.error)throw new Re(e.error.code,e.error.message);if(!e.result)throw new Re(p.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},De=(e,t)=>({requests:e.map((e=>{const s=new Te({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),r=t.equals(s);return{payload:e.ciphertext,peerKeys:r?new Te({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:r}}))});class Me{constructor(e){this.authorityId=e.authorityId,this.typeId=e.typeId,this.versionMajor=e.versionMajor,this.versionMinor=e.versionMinor}toString(){return`${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`}static fromString(e){const[t,s]=e.split(":"),[r,n]=t.split("/"),[i,o]=s.split(".");return new Me({authorityId:r,typeId:n,versionMajor:Number(i),versionMinor:Number(o)})}sameAs(e){return this.authorityId===e.authorityId&&this.typeId===e.typeId}}const _e=new Me({authorityId:"brixbit.org",typeId:"fallback",versionMajor:1,versionMinor:0}),xe=new Me({authorityId:"brixbit.org",typeId:"text",versionMajor:1,versionMinor:0});var Ve;!function(e){e.utf8="UTF-8"}(Ve||(Ve={}));class Ue{get contentType(){return xe}encode(e){return{type:xe,parameters:{encoding:Ve.utf8},content:(new TextEncoder).encode(e)}}decode(e){const t=e.parameters.encoding;if(t&&t!==Ve.utf8)throw new Error(`unrecognized encoding ${t}`);return(new TextDecoder).decode(e.content)}fallback(e){}}class qe{constructor(t,s,r){this.conversationVersion="v1",this.context=void 0,this.peerAddress=e(s),this.client=t,this.createdAt=r}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return I(this.peerAddress,this.client.address)}get ephemeralTopic(){return I(this.peerAddress,this.client.address).replace("/brixbit/0/dm-","/brixbit/0/dmE-")}async messages(e){const t=I(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof Te||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[D(this.peerAddress),D(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const i=await this.client.encodeContent(e,t),o=await this.createMessage(i,r,t?.timestamp),a=o.toBytes(),c={contentTopic:n,message:a,timestampNs:H(o.sent)};return new Ie(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a,timestamp:o.sent})))),$e.fromV1Message(o,e,t?.contentType||xe,i,n,this))))}streamMessages(e){return Q.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await Ge.fromBytes(e),{senderAddress:r,recipientAddress:n}=s;if(!r||!n||!t||I(r,n)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return Q.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,r=await this.client.getUserContact(this.peerAddress);if(!r)throw new Error(`recipient ${this.peerAddress} is not registered`);r instanceof Te||(r=r.toLegacyBundle());const n=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[n]:(s=[D(this.peerAddress),D(this.client.address),n],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||xe,o=await this.client.encodeContent(e,t),a=await this.createMessage(o,r,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a.toBytes(),timestamp:a.sent})))),"unknown"===this.consentState&&await this.allow(),$e.fromV1Message(a,e,i,o,n,this)}async decryptBatch(e,t,s=!1){const r=(await this.client.keystore.decryptV1(De(e,this.client.publicKeyBundle))).responses,n=[];for(let i=0;i<r.length;i++){const o=r[i],a=e[i];try{const{decrypted:e}=Ne(o);n.push(await this.buildDecodedMessage(a,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return n}async buildDecodedMessage(e,t,s){const{content:r,contentType:n,error:i,contentFallback:o}=await this.client.decodeContent(t);return $e.fromV1Message(e,r,n,t,s,this,i,o)}async createMessage(e,t,s){return s=s||new Date,Ge.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class Oe{constructor(e,t,s,r,n){this.conversationVersion="v2",this.topic=t,this.createdAt=r,this.context=n,this.client=e,this.peerAddress=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/brixbit/0/m","/brixbit/0/mE")}streamEphemeral(e){return Q.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return Q.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const s=await this.client.encodeContent(e,t),r=await this.createMessage(s,t?.timestamp),n=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:n,message:r.toBytes(),timestamp:r.sent}]);const i=t?.contentType||xe;return"unknown"===this.consentState&&await this.allow(),$e.fromV2Message(r,e,i,n,s,this,this.client.address)}async createMessage(e,t){const s={topic:this.topic,createdNs:F(t||new Date)},r=l.MessageHeaderV2.encode(s).finish(),n=await se(J(r,e)),i={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:n,prekeyIndex:0,identityKey:void 0})},o=w.SignedContent.encode(i).finish(),a={v1:void 0,v2:{headerBytes:r,ciphertext:await this.encryptMessage(o,r)}},c=l.Message.encode(a).finish();return He.create(a,s,c)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,r=[];for(let n=0;n<s.length;n++){const i=s[n],o=e[n];try{const{decrypted:e}=Ne(i);r.push(await this.buildDecodedMessage(o,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return r}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:r}=Ne(s[0]);return r}async buildDecodedMessage(e,t){const s=w.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new Ee(s).verifyKey(new Ee(t)))throw new Error("pre key not signed by identity key")}(s);const r=await se(J(e.headerBytes,s.payload));if(!new Ee(s.sender?.preKey).verify(new fe(s.signature),r))throw new Error("invalid signature");const n=await new ke(s.sender).walletSignatureAddress(),{content:i,contentType:o,error:a,contentFallback:c}=await this.client.decodeContent(s.payload);return $e.fromV2Message(e,i,o,this.topic,s.payload,this,n,a,c)}async prepareMessage(e,t){const s=await this.client.encodeContent(e,t),r=await this.createMessage(s,t?.timestamp),n=r.toBytes(),i=t?.ephemeral?this.ephemeralTopic:this.topic,o={contentTopic:i,message:n,timestampNs:H(r.sent)};return new Ie(o,(async()=>(await this.client.publishEnvelopes([{contentTopic:i,message:n,timestamp:r.sent}]),$e.fromV2Message(r,e,t?.contentType||xe,i,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=l.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=l.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return He.create(t,s,e.message)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const Le=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new Z(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new Z(e.v2.ciphertext)];throw new Error("unknown message version")};class Fe{constructor(e,t,s){[this.headerBytes,this.ciphertext]=Le(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class Ge extends Fe{constructor(e,t,s,r,n){super(e,t,s),this.conversation=void 0,this.senderAddress=n,this.header=r}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const r=new Te(t.sender).walletSignatureAddress(),n=ae(await se(s));return new Ge(n,s,e,t,r)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new Ke(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(De([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:r}=Ne(s[0]);return r}static fromBytes(e){const t=l.Message.decode(e),[s]=Le(t),r=l.MessageHeaderV1.decode(s);if(!r)throw new Error("missing message header");if(!r.sender)throw new Error("missing message sender");if(!r.sender.identityKey)throw new Error("missing message sender identity key");if(!r.sender.preKey)throw new Error("missing message sender pre-key");if(!r.recipient)throw new Error("missing message recipient");if(!r.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!r.recipient.preKey)throw new Error("missing message recipient pre-key");return Ge.create(t,r,e)}static async encode(e,t,s,r,n){const i={sender:s,recipient:r,timestamp:a.fromNumber(n.getTime())},o=l.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:r,headerBytes:o,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=Ne(c.responses[0]),h={v1:{headerBytes:o,ciphertext:d},v2:void 0},y=l.Message.encode(h).finish();return Ge.create(h,i,y)}}class He extends Fe{constructor(e,t,s,r){super(e,t,s),this.header=r}static async create(e,t,s){const r=ae(await se(s));return new He(r,s,e,t)}get sent(){return G(this.header.createdNs)}}class $e{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:r,conversation:n,contentBytes:i,contentType:o,contentTopic:a,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=r,this.conversation=n,this.contentType=o,this.sent=d,this.error=h,this.content=c,this.contentTopic=a,this.contentBytes=i,this.contentFallback=y}toBytes(){return l.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:F(this.conversation.createdAt),peerAddress:this.conversation.peerAddress},sentNs:F(this.sent)}).finish()}static async fromBytes(e,t){const s=l.DecodedMessage.decode(e),r=s.messageVersion;if("v1"!==r&&"v2"!==r)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:n,contentType:i,error:o,contentFallback:a}=await t.decodeContent(s.contentBytes);return new $e({...s,content:n,contentType:i,error:o,messageVersion:r,sent:G(s.sentNs),conversation:je(s.conversation,t,r),contentFallback:a})}static fromV1Message(e,t,s,r,n,i,o,a){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new $e({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:o,contentFallback:a})}static fromV2Message(e,t,s,r,n,i,o,a,c){const{id:d,sent:h}=e;return new $e({id:d,messageVersion:"v2",senderAddress:o,sent:h,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:a,contentFallback:c})}}function je(e,t,s){if("v1"===s)return new qe(t,e.peerAddress,G(e.createdNs));if("v2"===s)return new Oe(t,e.topic,e.peerAddress,G(e.createdNs),e.context);throw new Error(`Unknown conversation version ${s}`)}function Xe(e,t){return t.decodeContent(e)}class Je{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:ze,SortDirection:Ye}=f,We={local:"http://localhost:5555",dev:"https://dev.brixbit.network",production:"https://production.brixbit.network"};var Qe;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(Qe||(Qe={}));class Ze extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new Ze(e.message,e.code)}}const et=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),tt=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),st=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=j(e.message)),e):e;class rt{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="brixbit-js/11.4.1",e===We.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the BRIXBIT 'dev' network. Use 'production' for production messages.\nhttps://github.com/brixbit/brixbit-js#brixbit-production-and-dev-network-environments\n")}async _query(e){try{return await O(ze.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw Ze.fromObject(e)}}_batchQuery(e){return O(ze.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),r=this.headers();r.set("Authorization",`Bearer ${s}`);try{return await O(ze.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:r}],this.maxRetries,100,tt)}catch(s){if(tt(s)||t>=1)throw Ze.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const r=new AbortController;return(async()=>{for(;;){const n=(new Date).getTime();try{if(await ze.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:r.signal,mode:"cors",headers:this.headers()}),r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await U(1e3),s?.()}catch(e){if(et(e)||r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-n<1e3&&await U(1e3),s?.()}}})(),{unsubscribe:async()=>{r?.abort()}}}async query(e,{direction:t=Ye.SORT_DIRECTION_ASCENDING,limit:s}){const r=[];for await(const n of this.queryIteratePages(e,{direction:t,pageSize:s&&s<100?s:100}))for(const e of n)if(r.push(e),s&&r.length===s)return r;return r}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:r,pageSize:n=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=H(t),o=H(s);let a;for(;;){const t={limit:n,direction:r,cursor:a},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:o,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(st),!s.pagingInfo?.cursor)return;a=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const r=e.slice(s,s+50),n=[];for(const e of r)n.push({contentTopics:[e.contentTopic],startTimeNs:H(e.startTime),endTimeNs:H(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||Ye.SORT_DIRECTION_ASCENDING}});const i={requests:n};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),r=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?r.push(t.envelopes.map(st)):r.push([])}return r}async publish(e){const t=[];for(const{contentTopic:s,message:r,timestamp:n}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!r.length)throw new Error("0 length messages not allowed");const e=n||new Date;t.push({contentTopic:s,timestampNs:H(e),message:Uint8Array.from(r)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(st(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new Je(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class nt{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new k,this.keystore=t}get protoJobType(){return function(e){const t={v1:p.JobType.JOB_TYPE_REFRESH_V1,v2:p.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":p.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,r=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),r}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:F(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(p.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(a.fromNumber(0)))return G(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:F(e)})}}const it=e=>Boolean(e.recipientAddress&&e.senderAddress);class ot{constructor(e){this.client=e,this.v1JobRunner=new nt("v1",e.keystore),this.v2JobRunner=new nt("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:Ye.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:F(t),topic:I(e,this.client.address),context:void 0}))).filter((e=>V(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),r=new Set(t.map((e=>e.topic)));for(const e of s)r.has(e.topic)||(t.push(e),r.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:Ye.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:a.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>V(e.contentTopic)))}),r=[];for(const e of s)try{r.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return r}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new Oe(this.client,e.topic,e.peerAddress,G(e.createdNs),e.context)}conversationReferenceToV1(e){return new qe(this.client,e.peerAddress,G(e.createdNs))}async stream(e){const t=new Set,s=D(this.client.address),r=M(this.client.address),n=[s,r];return Q.create(this.client,n,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await Ge.fromBytes(e.message),r=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(r))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new qe(this.client,r,s.sent)}if(e.contentTopic===r){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=D(this.client.address),s=M(this.client.address),r=new Set([t,s]),n=new Map;for(const e of await this.list())r.add(e.topic),n.set(e.topic,e);const i=(e,t)=>!r.has(e)&&(n.set(e,t),r.add(e),!0),o=await Q.create(this.client,Array.from(r.values()),(async e=>{const r=e.contentTopic;if(!r||!e.message)return null;if(r===t){const t=await Ge.fromBytes(e.message);if(!it(t))return null;const s=this.getPeerAddress(t);return new qe(this.client,s,t.sent).decodeMessage(e)}if(r===s){return(await this.decodeInvites([e],!0))[0]}const i=n.get(r);if(i instanceof qe)return i.decodeMessage(e);if(i instanceof Oe)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof $e&&e.contentTopic===t){const t=new qe(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(r.values()):void 0}if(e instanceof Oe){return i(e.topic,e)?Array.from(r.values()):void 0}}),e),a=async function*(){for await(const e of o)if(e instanceof $e&&(yield e),e instanceof Oe)for(const t of await e.messages())yield t}();return a.return=async()=>(await(o?.return()),{value:void 0,done:!0}),a}async getIntroductionPeers(e){const t=D(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return Ge.fromBytes(e.message)}),e),r=new Map;for(const e of s){if(!it(e))continue;const t=this.getPeerAddress(e);if(t){const s=r.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),r.set(t,e.sent)}catch(e){continue}}}return r}async newConversation(e,t){let s=await this.client.getUserContact(e);if(!s)throw new Error(`Recipient ${e} is not on the BRIXBIT network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(s instanceof Te&&!t?.conversationId)return new qe(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(s instanceof Te||s.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}s instanceof Te&&(s=ke.fromLegacyBundle(s));const r=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(r=t,n=s.context??void 0,r?.conversationId===n?.conversationId);var r,n},n=(await this.getV2ConversationsFromKeystore()).find(r);return n||this.v2JobRunner.run((async e=>{const n=(await this.updateV2Conversations(e)).find(r);return n||this.createV2Convo(s,t)}))}async createV2Convo(e,t){const s=new Date,{payload:r,conversation:n}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:F(s)});if(!r||!n)throw new Error("Required field not returned from Keystore");const i=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:M(i),message:r,timestamp:s},{contentTopic:M(this.client.address),message:r,timestamp:s}]),await this.client.contacts.allow([i]),this.conversationReferenceToV2(n)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}function at(e){if(e===w.Compression.COMPRESSION_GZIP)return"gzip";if(e===w.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function ct(e,t=1024){let s=0;return new ReadableStream({pull(r){if(s>=e.length)return r.close();let n=s+t;n=n<=e.length?n:e.length,r.enqueue(e.subarray(s,n)),s=n}})}function dt(e,t){let s=0;return new WritableStream({write(r){const n=s+r.length;if(n>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<n;)e.bytes=ht(e.bytes,t);e.bytes.set(r,s),s=n},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function ht(e,t){let s=2*e.length;s>t&&(s=t);const r=new Uint8Array(s);return r.set(e),r}function yt(e){let t;try{t=m.ContactBundle.decode(e)}catch(s){const r=u.PublicKeyBundle.decode(e);t={v1:{keyBundle:new Te(r)},v2:void 0}}if(t.v1?.keyBundle)return new Te(t.v1.keyBundle);if(t.v2?.keyBundle)return new ke(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function ut(e){return e instanceof Te?m.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():m.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}class pt{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new pt({walletAddr:e,createdNs:F(t)})}static fromBytes(e){const t=g.AuthData.decode(e);return new pt(t)}toBytes(){return g.AuthData.encode(this).finish()}}class lt{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=pt.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return g.Token.encode(this).finish()}static fromBytes(e){return new lt(g.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class wt{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=pt.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),r=s(t),i=await this.identityKey.sign(n(r));return new lt(g.Token.fromPartial({identityKey:u.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:y.Signature.fromPartial(i)}))}}class ft{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof lt?e:new lt(e))(await this.keystore.createAuthToken({timestampNs:e?F(e):void 0}))}}var mt;!function(e){e[e.none=0]="none",e[e.brixbitTopicStore=1]="brixbitTopicStore"}(mt||(mt={}));const gt=mt.none;class vt{static createConfiguration(){return{type:gt,version:0}}constructor(e){this.configuration=e}get backupType(){return gt}}const bt=mt.brixbitTopicStore;class Et{static createConfiguration(e){return{type:bt,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return bt}}async function Kt(e,t){const s=await async function(e,t){let s;switch((await t()).type){case mt.none:s=vt.createConfiguration();break;case mt.brixbitTopicStore:s=Et.createConfiguration(e)}return s}(e,t);switch(s.type){case mt.none:return new vt(s);case mt.brixbitTopicStore:return new Et(s)}}class kt extends Error{}class Tt{constructor({topic:e,context:t,aes256GcmHkdfSha256:s}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s}static createRandom(e){const t=R(Buffer.from(ee.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),s=ee.getRandomValues(new Uint8Array(32));return new Tt({topic:t,aes256GcmHkdfSha256:{keyMaterial:s},context:e})}toBytes(){return v.InvitationV1.encode(this).finish()}static fromBytes(e){return new Tt(v.InvitationV1.decode(e))}}class At{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new ke(e),this.recipient=new ke(t),this.createdNs=s}toBytes(){return v.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new At(v.SealedInvitationHeaderV1.decode(e))}}class St{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new Z(t)}get header(){return this._header||(this._header=At.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const r=await ne(this.ciphertext,s,this.headerBytes);return this._invitation=Tt.fromBytes(r),this._invitation}toBytes(){return v.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new St(v.SealedInvitationV1.decode(e))}}class Ct{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new St(e)}toBytes(){return v.SealedInvitation.encode(this).finish()}static fromBytes(e){return new Ct(v.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=Ct.fromBytes(e.message),s=a.fromString(e.timestampNs),r=t.v1?.header.createdNs;if(!r||!r.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:r}){const n=new At({sender:e.getPublicKeyBundle(),recipient:t,createdNs:F(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),o=r.toBytes(),a=await re(o,i,n);return new Ct({v1:{headerBytes:n,ciphertext:a}})}}const Pt=async(e,t,s,r)=>re(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),r),Bt=(e,t,s)=>re(e,t,s),It=(e,t)=>e instanceof Re?e:new Re(t,e.message),Rt=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:It(e,s)}}}))),Nt=e=>e instanceof Te?e:new Te(e),Dt=(e,t,s)=>{for(const s of t)if(!e[s])throw new Re(p.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new Re(p.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},Mt=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new Re(p.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},_t=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t});class xt{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new k,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new xt(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?function(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,function(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,r]of Object.entries(e.topics))t.set(s,r);return t})(p.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...r}=s;this.topicMap.has(e)||(this.topicMap.set(e,r),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return p.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class Vt extends xt{static async create(e){const t=new Vt(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const Ut=new(0,T.ec)("secp256k1"),qt=ee.subtle,Ot=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),Lt=Buffer.alloc(32,0);function Ft(e,t){if(!e)throw new Error(t||"Assertion failed")}function Gt(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(Lt)>0&&e.compare(Ot)<0);var t}function Ht(e){const t=new Uint8Array(e);return ee.getRandomValues(t),Buffer.from(t)}async function $t(e){const t=await qt.digest("SHA-512",e);return Buffer.from(t)}function jt(e){return function(t,s,r){return new Promise((function(n){return qt.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const n={name:"AES-CBC",iv:t};return qt[e](n,s,r)})).then((function(e){n(Buffer.from(new Uint8Array(e)))}))}))}}const Xt=jt("encrypt"),Jt=jt("decrypt");async function zt(e,t){const s=await qt.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await qt.sign({name:"HMAC",hash:"SHA-256"},s,t))}function Yt(e){return Ft(32===e.length,"Bad private key"),Ft(Gt(e),"Bad private key"),Buffer.from(Ut.keyFromPrivate(e).getPublic("array"))}function Wt(e,t){return new Promise((function(s){Ft(Buffer.isBuffer(e),"Bad private key"),Ft(Buffer.isBuffer(t),"Bad public key"),Ft(32===e.length,"Bad private key"),Ft(Gt(e),"Bad private key"),Ft(65===t.length||33===t.length,"Bad public key"),65===t.length&&Ft(4===t[0],"Bad public key"),33===t.length&&Ft(2===t[0]||3===t[0],"Bad public key");const r=Ut.keyFromPrivate(e),n=Ut.keyFromPublic(t),i=r.derive(n.getPublic());s(Buffer.from(i.toArray()))}))}async function Qt(e,t){const s=await Wt(e,t.ephemeralPublicKey),r=await $t(s),n=r.slice(0,32),i=r.slice(32),o=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return Ft(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let r=0;r<e.length;r++)s|=e[r]^t[r];return 0===s}(await zt(e,t),s)}(i,o,t.mac),"Bad mac"),Jt(t.iv,n,t.ciphertext)}async function Zt(e,t){await A();const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return S(s,r,t)}async function es(e,t){await A();const s=e.publicKey.secp256k1Uncompressed.bytes,r=e.secp256k1.bytes;return C(s,r,t)}const{ErrorCode:ts}=p,ss=(new TextEncoder).encode("__BRIXBIT__INVITATION__SALT__BRIXBIT__");class rs{constructor(e,t,s,r){this.v1Keys=e,this.v2Keys=Se.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.authenticator=new wt(e.identityKey),this.jobStatePersistence=r}static async create(e,t){return new rs(e,await Vt.create(t),await xt.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await Rt(e.requests,(async e=>{Dt(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:r,isSender:n}=e,i=await(async(e,t,s,r,n)=>ne(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!n),r))(this.v1Keys,Nt(s),t,r,n);return{decrypted:i}}),p.ErrorCode.ERROR_CODE_UNSPECIFIED);return p.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await Rt(e.requests,(async e=>{Dt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new Re(p.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=await((e,t,s)=>ne(e,t,s))(t,Mt(n.invitation),s);return{decrypted:i}}),ts.ERROR_CODE_UNSPECIFIED);return p.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await Rt(e.requests,(async e=>{Dt(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:r}=e;return{encrypted:await Pt(this.v1Keys,Nt(t),s,r)}}),ts.ERROR_CODE_UNSPECIFIED);return p.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?G(e):void 0)}async selfEncrypt(e){const t=await Rt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Re(ts.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await Zt(this.v1Keys.identityKey,t)}}),ts.ERROR_CODE_INVALID_INPUT);return p.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await Rt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Re(ts.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await es(this.v1Keys.identityKey,t)}}),ts.ERROR_CODE_INVALID_INPUT);return p.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){await A();const t=e.secp256k1.bytes;return P(t)}(this.v1Keys.identityKey);return p.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await Rt(e.requests,(async e=>{Dt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:r}=e,n=this.v2Store.lookup(r);if(!n)throw new Re(ts.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return{encrypted:await Bt(t,Mt(n.invitation),s)}}),ts.ERROR_CODE_INVALID_INPUT);return p.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await Rt(e.requests,(async({payload:e,timestampNs:s})=>{const r=Ct.fromBytes(e);if(r.v1){if(!r.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=r.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),n=await r.v1.getInvitation(this.v2Keys),i={invitation:n,createdNs:r.v1.header.createdNs,peerAddress:e?await r.v1.header.recipient.walletSignatureAddress():await r.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:n.topic}),{conversation:_t(i)}}}),ts.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),p.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{Dt(e,["recipient"],[]);const s=G(e.createdNs),r=(t=e.recipient)instanceof ke?t:new ke(t),n=await this.getAccountAddress(),i=await r.walletSignatureAddress(),o=await this.v2Keys.sharedSecret(r,this.v2Keys.getCurrentPreKey().publicKey,n<i),a=[n,i].sort(),c=(e.context?.conversationId||"")+a.join(),d=(new TextEncoder).encode(c),h=ae(await zt(Buffer.from(o),Buffer.from(d))),y=["0",...a].join("|"),u=(new TextEncoder).encode(y),l=await async function(e,t){const s=await ee.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return ee.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:ss,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(o,u),w=new Uint8Array(await ee.subtle.exportKey("raw",l)),f=new Tt({topic:R(h),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context}),m=await Ct.createV1({sender:this.v2Keys,recipient:r,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await r.walletSignatureAddress()};return await this.v2Store.add([g]),p.CreateInviteResponse.fromPartial({conversation:_t(g),payload:m.toBytes()})}catch(e){throw It(e,ts.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){Dt(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:r}=e;let n;if(s)n=this.v1Keys.identityKey;else{if(void 0===r||!Number.isInteger(r))throw new Re(ts.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(n=this.v1Keys.preKeys[r],!n)throw new Re(ts.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return n.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:I(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>_t(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),p.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===p.JobType.JOB_TYPE_UNSPECIFIED)throw new Re(ts.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return p.GetRefreshJobResponse.fromPartial({lastRunNs:t||a.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:I(e.peerAddress,this.walletAddress),context:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return a.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}}class ns{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:f.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return _(e)}}class is{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new is(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class os{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class as extends is{static create(){return new is(new os)}}class cs{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}class ds{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=Yt(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const r=s?.iv||Ht(16);let n=s?.ephemPrivateKey||Ht(32);for(;!Gt(n);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");n=Ht(32)}const i=Yt(n),o=await $t(await Wt(n,e)),a=o.slice(0,32),c=o.slice(32),d=await Xt(r,a,t),h=Buffer.concat([r,i,d]);return{iv:r,ephemeralPublicKey:i,ciphertext:d,mac:await zt(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await Qt(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await Be.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=Be.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}const hs=async(e,t)=>{if(!e.persistConversations)return as.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),r=`brixbit/${e.env}/${s}/`;const n=e.basePersistence,i=!e.disablePersistenceEncryption;return new cs(r,i?new ds(n,t.identityKey):n)},ys="key_bundle";class us{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(t){let s=await this.signer.getAddress();return s=e(s),`${s}/${t}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(ys));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(ys),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new wt(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,t){const s=e.encode(),r=ee.getRandomValues(new Uint8Array(32)),i=ls(r),a=await t.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const c=await t.signMessage(i);if(!o({address:a,message:i,signature:c}))throw new Error("invalid signature");const d=n(c),y=await re(s,d);return h.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:r,ciphertext:y}}).finish()}async fromEncryptedBytes(e,t){const[s,r]=function(e){try{const t=h.EncryptedPrivateKeyBundle.decode(e);if(t.v1)return[t.v1,!1]}catch(t){return[h.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(t);if(!s.walletPreKey)throw new Error("missing wallet pre-key");if(!s.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=n(await e.signMessage(ls(s.walletPreKey)));try{const e=new Z(s.ciphertext),t=await ne(e,i),[n,o]=ps(t);return[n,r||o]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let n=i.slice(0,i.length-1);n=t<27?new Uint8Array([...n,t+27]):new Uint8Array([...n,t-27]);const o=new Z(s.ciphertext),a=await ne(o,n),[c,d]=ps(a);return[c,r||d]}}}function ps(e){try{const t=Pe(e);if(t instanceof Se)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(t){const s=h.PrivateKeyBundleV1.decode(e);return[new Ce(s),!0]}}function ls(e){return`BRIXBIT : Enable Identity\n${ae(e)}\n\nFor more info: https://brixbit.org/signatures/`}class ws{async newKeystore(e,t,s){if(!s)throw new kt("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const r=await Ce.generate(s),n=new us(s,new ns(t),e.preEnableIdentityCallback);return await n.storePrivateKeyBundle(r),rs.create(r,await hs(e,r))}}class fs{async newKeystore(e,t,s){if(!s)throw new kt("No wallet provided");const r=new us(s,new ns(t),e.preEnableIdentityCallback),n=await r.loadPrivateKeyBundle();if(!n)throw new kt("No keys found");return rs.create(n,await hs(e,n))}}class ms{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new kt("No private key override provided");const s=Pe(t);if(s instanceof Se)throw new Error("V2 private key bundle found. Only V1 supported");return rs.create(s,await hs(e,s))}}function gs(){return window.ethereum}const{GetKeystoreStatusResponse_KeystoreStatus:vs,InitKeystoreRequest:bs,InitKeystoreResponse:Es,GetKeystoreStatusRequest:Ks,GetKeystoreStatusResponse:ks}=p;async function Ts(e,t,s,r,n){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=X(e,0,e.length)}const o=await async function(e,t,s,r){const n={meta:s};"string"==typeof t&&(n.req=t);const i=await(gs()?.request({method:"wallet_invokeSnap",params:{snapId:r,request:{method:e,params:n}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,r,n);if(Array.isArray(o))throw new Error("Unexpected array response");return t.res.decode(j(o))}async function As(){const e=gs();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function Ss(e,t){try{const s=await async function(){return await(gs()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(r=s.version,n=t,!r||!n||z(r).major===z(n).major));var r,n})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const Cs={req:Ks,res:ks};const Ps={req:bs,res:Es};const Bs={decryptV1:{req:p.DecryptV1Request,res:p.DecryptResponse},decryptV2:{req:p.DecryptV2Request,res:p.DecryptResponse},encryptV1:{req:p.EncryptV1Request,res:p.EncryptResponse},encryptV2:{req:p.EncryptV2Request,res:p.EncryptResponse},saveInvites:{req:p.SaveInvitesRequest,res:p.SaveInvitesResponse},createInvite:{req:p.CreateInviteRequest,res:p.CreateInviteResponse},createAuthToken:{req:p.CreateAuthTokenRequest,res:g.Token},signDigest:{req:p.SignDigestRequest,res:y.Signature},getPublicKeyBundle:{req:null,res:u.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:h.PrivateKeyBundleV1},saveV1Conversations:{req:p.SaveV1ConversationsRequest,res:p.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:p.GetConversationsResponse},getV2Conversations:{req:null,res:p.GetConversationsResponse},getRefreshJob:{req:p.GetRefreshJobRequest,res:p.GetRefreshJobResponse},setRefreshJob:{req:p.SetRefeshJobRequest,res:p.SetRefreshJobResponse},selfEncrypt:{req:p.SelfEncryptRequest,res:p.SelfEncryptResponse},selfDecrypt:{req:p.SelfDecryptRequest,res:p.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:p.GetPrivatePreferencesTopicIdentifierResponse}},Is={...Bs,getKeystoreStatus:{req:p.GetKeystoreStatusRequest,res:p.GetKeystoreStatusResponse},initKeystore:{req:p.InitKeystoreRequest,res:p.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:Rs}=p;class Ns{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new kt("No wallet provided");if(!await As())throw new kt("MetaMask with Snaps not detected");const r=await s.getAddress(),n=e.env,i=await Ss(this.snapId,this.snapVersion);if(i&&!Y(this.snapVersion,i.version)||await async function(e,t={}){await(gs()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const r=await async function(e,t){const s=await Ts("getKeystoreStatus",Cs,{walletAddress:e.walletAddress},e,t);if([vs.KEYSTORE_STATUS_UNSPECIFIED,vs.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(r===Rs.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(r,n,this.snapId)){const r=await async function(e,t,s){if(e.privateKeyOverride){const t=Pe(e.privateKeyOverride);if(!(t instanceof Ce))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const r=new fs;try{const n=await r.newKeystore(e,t,s);return new Ce(await n.getPrivateKeyBundle())}catch(r){if(r instanceof kt)return async function(e,t,s){const r=new ws,n=await r.newKeystore(e,t,s);return new Ce(await n.getPrivateKeyBundle())}(e,t,s);throw r}}(e,t,s)}(e,t,s);await async function(e,t,s){const r=e.identityKey.publicKey.walletSignatureAddress(),n=await Ts("initKeystore",Ps,{v1:e},{walletAddress:r,env:t},s);if(n.error)throw new Re(n.error.code,n.error.message)}(r,n,this.snapId)}return function(e,t,s){const r={},n={walletAddress:e,env:t};for(const[e,t]of Object.entries(Is))r[e]=async r=>t.req?Ts(e,t,r,n,s):Ts(e,t,void 0,n,s);return{...r,getAccountAddress:async()=>e}}(r,n,this.snapId)}}class Ds{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new Ds(e,"address",t)}}class Ms{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=Ds.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=Ds.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=Ds.fromAddress(e);return this.entries.get(t.key)??"unknown"}async getIdentifier(){if(!this._identifier){const{identifier:e}=await this.client.keystore.getPrivatePreferencesTopicIdentifier();this._identifier=e}return this._identifier}async decodeMessages(e){const{responses:t}=await this.client.keystore.selfDecrypt({requests:e.map((e=>({payload:e})))});return t.reduce(((e,t)=>t.result?.decrypted?e.concat(b.PrivatePreferencesAction.decode(t.result.decrypted)):e),[])}processActions(e,t){const s=[];return e.forEach((e=>{e.allow?.walletAddresses.forEach((e=>{s.push(this.allow(e))})),e.block?.walletAddresses.forEach((e=>{s.push(this.deny(e))}))})),t&&(this.lastEntryTimestamp=$(t)),s}async stream(e){const t=await this.getIdentifier(),s=x(t);return Q.create(this.client,[s],(async e=>{if(!e.message)return;const t=await this.decodeMessages([e.message]);return this.processActions(t,e.timestampNs),t[0]}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.getIdentifier(),s=x(t);let r;const n=await this.client.listEnvelopes(s,(async({message:e,timestampNs:t})=>(t&&(r=t),e)),{startTime:e}),i=await this.decodeMessages(n);return this.processActions(i,r)}async publish(e){const t=await this.getIdentifier(),s=e.reduce(((e,t)=>{if("address"===t.entryType){const s={allow:"allowed"===t.permissionType?{walletAddresses:[t.value]}:void 0,block:"denied"===t.permissionType?{walletAddresses:[t.value]}:void 0};return e.concat(b.PrivatePreferencesAction.encode(s).finish())}return e}),[]),{responses:r}=await this.client.keystore.selfEncrypt({requests:s.map((e=>({payload:e})))}),n=r.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),i=x(t),o=new Date,a=n.map((e=>({contentTopic:i,message:e,timestamp:o})));await this.client.publishEnvelopes(a),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class _s{constructor(e){this.addresses=new Set,this.consentList=new Ms(e),this.client=e,this.jobRunner=new nt("user-preferences",e.keystore)}async loadConsentList(e){return this.jobRunner.run((async t=>this.consentList.load(e??t)))}async refreshConsentList(){return this.consentList.reset(),await this.jobRunner.resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return this.consentList.stream(e)}get lastConsentListEntryTimestamp(){return this.consentList.lastEntryTimestamp}setConsentListEntries(e){e.length&&(this.consentList.reset(),e.forEach((e=>{"allowed"===e.permissionType&&this.consentList.allow(e.value),"denied"===e.permissionType&&this.consentList.deny(e.value)})))}isAllowed(e){return"allowed"===this.consentList.state(e)}isDenied(e){return"denied"===this.consentList.state(e)}consentState(e){return this.consentList.state(e)}async allow(e){await this.consentList.publish(e.map((e=>Ds.fromAddress(e,"allowed"))))}async deny(e){await this.consentList.publish(e.map((e=>Ds.fromAddress(e,"denied"))))}}const{Compression:xs}=w,Vs=104857600;class Us{constructor(e,t,s,r){this.knownPublicKeyBundles=new Map,this.keystore=r,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new ot(this),this._codecs=new Map,this._maxContentSize=Vs,this.apiClient=t,this._backupClient=s,this.contacts=new _s(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return ke.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=W(e),r=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new Ue],maxContentSize:Vs,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?is.create():as.create(),disablePersistenceEncryption:!1,keystoreProviders:Fs(),apiClientFactory:qs};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Ns("npm:@brixbit/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),n=r.apiClientFactory(r),i=await async function(e,t,s){for(const r of e.keystoreProviders)try{return await r.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof kt)continue;throw e}throw new Error("No keystore providers available")}(r,n,s),o=new Te(await i.getPublicKeyBundle()),a=o.walletSignatureAddress();n.setAuthenticator(new ft(i));const c=await Us.setupBackupClient(a,r.env),d=new Us(o,n,c,i);return await d.init(r),d}static async getKeys(e,t){const s=await Us.create(W(e),t),r=await s.keystore.getPrivateKeyBundle();return new Ce(r).encode()}static isSnapsReady(){return As()}static async setupBackupClient(e,t){return Kt(e,(async()=>Promise.resolve({type:"local"===t?mt.brixbitTopicStore:mt.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await Os(this.apiClient,this.address);t&&t instanceof ke&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:N(this.address),message:ut(t)}])}async getUserContact(t){t=e(t);const s=this.knownPublicKeyBundles.get(t);if(s)return s;const r=await Os(this.apiClient,t);return r&&this.knownPublicKeyBundles.set(t,r),r}async getUserContacts(t){const s=t.map((t=>e(t))),r=new Map,n=[];for(const e of s){const t=this.knownPublicKeyBundles.get(e);t?r.set(e,t):(r.set(e,void 0),n.push(e))}const i=await Ls(this.apiClient,n);for(let e=0;e<i.length;e++){const t=n[e],s=i[e];r.set(t,s),s&&this.knownPublicKeyBundles.set(t,s)}return s.map((e=>r.get(e)))}forgetContact(t){t=e(t),this.knownPublicKeyBundles.delete(t)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(t,s){const r=s?.apiUrl||We[s?.env||"dev"],n=new rt(r,{appVersion:s?.appVersion});if(Array.isArray(t)){const s=t.map((t=>e(t)));return(await Ls(n,s)).map((e=>!!e))}try{t=e(t)}catch(e){return!1}return void 0!==await Os(n,t)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||xe,r=this.codecFor(s);if(!r)throw new Error("unknown content type "+s);const n=r.encode(e,this),i=r.fallback(e);return i&&(n.fallback=i),"number"==typeof t?.compression&&n.content.length>=10&&(n.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await ct(e.content).pipeThrough(new CompressionStream(at(e.compression))).pipeTo(dt(t,e.content.length+1e3)),e.content=t.bytes}(n),w.EncodedContent.encode(n).finish()}async decodeContent(e){const t=w.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const r=new Me(t.type);let n;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await ct(e.content).pipeThrough(new DecompressionStream(at(e.compression))).pipeTo(dt(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(r);return i?s=i.decode(t,this):n=new Error("unknown content type "+r),{content:s,contentType:r,error:n,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(M(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:r,endTime:n,limit:i}=s,o=await this.apiClient.query({contentTopic:e,startTime:r,endTime:n},{direction:s.direction||f.SortDirection.SORT_DIRECTION_ASCENDING,limit:i}),a=[];for(const e of o)if(e.message)try{const s=await t(e);a.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return a}listEnvelopesPaginated(e,t,s){return L(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function qs(e){const t=e.apiUrl||We[e.env];return new rt(t,{appVersion:e.appVersion})}async function Os(e,t){const s=e.queryIterator({contentTopic:N(t)},{pageSize:5,direction:Ye.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=yt(e.message);let r;try{r=await(s?.walletSignatureAddress())}catch(e){r=void 0}if(r?.toLowerCase()===t.toLowerCase())return s}}async function Ls(e,t){const s=t.map(N),r=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:Ye.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=r[t];if(s)for(const t of s)if(t.message)try{const s=yt(t.message),r=await(s?.walletSignatureAddress());if(e.toLowerCase()===r.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function Fs(){return[new ms,new fs,new ws]}const Gs=new Me({authorityId:"brixbit.org",typeId:"composite",versionMajor:1,versionMinor:0});class Hs{get contentType(){return Gs}encode(e,t){const s=this.toProto(e,t);let r;r=s.composite?s.composite:{parts:[s]};const n=E.Composite.encode(r).finish();return{type:Gs,parameters:{},content:n}}decode(e,t){return this.fromProto({composite:E.Composite.decode(e.content),part:void 0},t)}toProto(e,t){if("type"in e){const s=t.codecFor(e.type);if(!s)throw new Error(`missing codec for part type ${e.type}`);return{part:s.encode(e.content,t),composite:void 0}}const s=new Array;for(const r of e.parts)s.push(this.toProto(r,t));return{composite:{parts:s},part:void 0}}fromProto(e,t){if(e.part){if(!e.part.type)throw new Error("missing part content type");const s=new Me(e.part.type),r=t.codecFor(s);if(!r)throw new Error(`missing codec for part type ${s}`);return{type:s,content:r.decode(e.part,t)}}if(!e.composite)throw new Error("invalid composite");const s=new Array;for(const r of e.composite.parts)s.push(this.fromProto(r,t));return{parts:s}}fallback(e){}}export{We as ApiUrls,Je as AuthCache,is as BrowserStoragePersistence,Z as Ciphertext,Us as Client,Hs as CompositeCodec,xs as Compression,Ds as ConsentListEntry,Gs as ContentTypeComposite,_e as ContentTypeFallback,Me as ContentTypeId,xe as ContentTypeText,qe as ConversationV1,Oe as ConversationV2,ot as Conversations,$e as DecodedMessage,ds as EncryptedPersistence,rt as HttpApiClient,rs as InMemoryKeystore,as as InMemoryPersistence,Tt as InvitationV1,ws as KeyGeneratorKeystoreProvider,wt as LocalAuthenticator,Ge as MessageV1,He as MessageV2,fs as NetworkKeystoreProvider,cs as PrefixedPersistence,ue as PrivateKey,Ce as PrivateKeyBundleV1,Se as PrivateKeyBundleV2,Ke as PublicKey,Te as PublicKeyBundle,Ct as SealedInvitation,fe as Signature,Ee as SignedPublicKey,ke as SignedPublicKeyBundle,Ns as SnapProvider,Ye as SortDirection,ms as StaticKeystoreProvider,Q as Stream,Ue as TextCodec,B as buildContentTopic,I as buildDirectMessageTopic,R as buildDirectMessageTopicV2,N as buildUserContactTopic,D as buildUserIntroTopic,M as buildUserInviteTopic,_ as buildUserPrivateStoreTopic,F as dateToNs,yt as decodeContactBundle,Xe as decodeContent,ne as decrypt,Fs as defaultKeystoreProviders,re as encrypt,$ as fromNanoString,Bs as keystoreApiDefs,L as mapPaginatedStream,G as nsToDate,O as retry,Is as snapKeystoreApiDefs,H as toNanoString};
//# sourceMappingURL=index.js.map
